"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-node_modules_arcgis_map-components_dist_esm_chunk-WQTCUXBS-9ec3781a_js"],{

/***/ "./node_modules/@arcgis/map-components/dist/esm/chunk-WQTCUXBS-9ec3781a.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@arcgis/map-components/dist/esm/chunk-WQTCUXBS-9ec3781a.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ AccessorController),
/* harmony export */   a: () => (/* binding */ accessorInternals),
/* harmony export */   b: () => (/* binding */ usePropertyChange),
/* harmony export */   c: () => (/* binding */ useT9n),
/* harmony export */   l: () => (/* binding */ load),
/* harmony export */   p: () => (/* binding */ proxyExports),
/* harmony export */   u: () => (/* binding */ useControllerManager)
/* harmony export */ });
/* harmony import */ var _index_6e172aac_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-6e172aac.js */ "./node_modules/@arcgis/map-components/dist/esm/index-6e172aac.js");
/* harmony import */ var _index_0bc55ca5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-0bc55ca5.js */ "./node_modules/@arcgis/map-components/dist/esm/index-0bc55ca5.js");
/*!
 * All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * See https://js.arcgis.com/4.30/esri/copyright.txt for details.
 * v4.30.0-next.37
 */



// src/stencil.ts
function retrieveComponentMeta(component) {
  const constructor = component.constructor;
  const members = constructor.__registerControllers?.(component) ?? void 0;
  constructor.__registerControllers = void 0;
  if (typeof members !== "object")
    throw new Error(
      "Failed to retrieve internal component meta. Make sure you have the useComponentsControllers() Rollup Plugin for Stencil Controllers configured in your Stencil config."
    );
  component.manager.internals.members = members;
}
function parsePropertyValue(value, type = 8 /* Any */) {
  const isComplex = value == null || typeof value === "object" || typeof value === "function";
  if (isComplex)
    return value;
  if ((type & 4 /* Boolean */) !== 0)
    return value === "false" ? false : value === "" || !!value;
  else if ((type & 2 /* Number */) !== 0)
    return Number.parseFloat(value.toString());
  else if ((type & 1 /* String */) !== 0)
    return String(value);
  else
    return value;
}
var makeMemberFilter = (filter) => (component) => {
  const members = component.manager.internals.members;
  return Object.entries(members ?? {}).filter(([_name, [propType]]) => (propType & filter) !== 0).map(([name]) => name);
};
var getPropLikeMembers = makeMemberFilter(63 /* PropLike */);
var getMemberType = (component, name) => component.manager.internals.members?.[name]?.[0];
function getPropType(component, name) {
  const type = getMemberType(component, name);
  if (type === void 0)
    return void 0;
  else if (type & 32 /* State */)
    return "state";
  else
    return "prop";
}

// ../components-utils/dist/index.js
var Deferred = class {
  /**
   * Creates a new deferred promise.
   */
  constructor() {
    this.resolve = () => void 0;
    this.reject = () => void 0;
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
};
function inTargetElement(element, targetElement) {
  let currentElement = element;
  while (currentElement) {
    if (currentElement === targetElement) {
      return true;
    }
    if (!currentElement.parentNode) {
      return false;
    }
    if (currentElement.parentNode instanceof ShadowRoot) {
      currentElement = currentElement.parentNode.host;
    } else {
      currentElement = currentElement.parentNode;
    }
  }
  return false;
}
function observeAncestorsMutation(element, attributeFilter, callback) {
  const { subscribe } = observe(attributeFilter);
  return subscribe((mutations) => {
    const matched = mutations.some((mutation) => inTargetElement(element, mutation.target));
    if (matched)
      callback();
  });
}
var observers = {};
function observe(attributeFilter) {
  const attributes = attributeFilter.join(",");
  const previousObserver = observers[attributes];
  if (previousObserver !== void 0)
    return previousObserver;
  const subscribers = /* @__PURE__ */ new Set();
  const mutationObserver = new MutationObserver((mutations) => subscribers.forEach((callback) => callback(mutations)));
  mutationObserver.observe(document.documentElement, {
    attributes: true,
    attributeFilter,
    subtree: true
  });
  const observer = {
    subscribe(callback) {
      subscribers.add(callback);
      return {
        remove: () => {
          subscribers.delete(callback);
          if (subscribers.size === 0) {
            mutationObserver.disconnect();
            observers[attributes] = void 0;
          }
        }
      };
    }
  };
  observers[attributes] = observer;
  return observer;
}
function closestElement(base, selector) {
  let currentElement = base;
  while (currentElement) {
    const element = currentElement.closest(selector);
    if (element) {
      return element;
    }
    const rootElement = currentElement.getRootNode();
    if (rootElement === document) {
      return null;
    }
    currentElement = rootElement.host;
  }
  return null;
}
function getElementAttribute(el, prop, fallbackValue) {
  const closest = closestElement(el, `[${prop}]`);
  return closest?.getAttribute(prop) ?? fallbackValue;
}
function safeCall(callback) {
  try {
    return callback?.();
  } catch (error) {
    console.error(error, callback);
  }
  return void 0;
}
async function safeAsyncCall(callback) {
  try {
    return await callback();
  } catch (error) {
    console.error(error, callback);
  }
  return void 0;
}
var capitalize = (string) => string.charAt(0).toUpperCase() + string.slice(1);
var camelToHuman = (value) => capitalize(value.replaceAll(/([a-z])([A-Z])/gu, "$1 $2"));
var supportedLocales = /* @__PURE__ */ new Set([
  "ar",
  "bg",
  "bs",
  "ca",
  "cs",
  "da",
  "de",
  "el",
  "en",
  "es",
  "et",
  "fi",
  "fr",
  "he",
  "hr",
  "hu",
  "id",
  "it",
  "ja",
  "ko",
  "lt",
  "lv",
  "nl",
  "nb",
  "pl",
  "pt-BR",
  "pt-PT",
  "ro",
  "ru",
  "sk",
  "sl",
  "sr",
  "sv",
  "th",
  "tr",
  "uk",
  "vi",
  "zh-CN",
  "zh-HK",
  "zh-TW"
]);
var defaultLocale = "en";
async function fetchT9NStringsBundle(locale, assetsPath, prefix = "") {
  const path = `${assetsPath}/${prefix}`;
  const filePath = `${path}${locale}.json`;
  t9nStringsCache[filePath] ?? (t9nStringsCache[filePath] = fetchBundle(locale, path));
  return await t9nStringsCache[filePath];
}
var t9nStringsCache = {};
async function fetchBundle(locale, path) {
  const filePath = `${path}${locale}.json`;
  try {
    const response = await fetch(filePath);
    if (response.ok)
      return await response.json();
  } catch (error) {
    console.error(error);
    return fallbackBundle;
  }
  if (locale === defaultLocale)
    return fallbackBundle;
  return await fetchBundle(defaultLocale, path);
}
var fallbackBundle = new Proxy(
  {},
  {
    get: (_target, property) => camelToHuman(property.toString())
  }
);
function getElementLocales(element) {
  const lang = getElementAttribute(element, "lang", navigator.language || defaultLocale);
  if (supportedLocales.has(lang)) {
    return { lang, t9nLocale: lang };
  }
  const rootCode = lang.slice(0, 2);
  return { lang, t9nLocale: supportedLocales.has(rootCode) ? rootCode : defaultLocale };
}
function startLocaleObserver(element, assetsPath, onUpdated, assetName) {
  let result = void 0;
  const callback = () => void updateComponentLocateState(element, assetsPath, assetName).then((newResult) => {
    if (result?.lang !== newResult.lang || result.t9nLocale !== newResult.t9nLocale || result.t9nStrings !== newResult.t9nStrings)
      onUpdated(newResult);
    result = newResult;
  }).catch(console.error);
  callback();
  return observeAncestorsMutation(element, ["lang"], callback);
}
async function updateComponentLocateState(element, assetsPath, assetName = element.tagName.toLowerCase().replace("arcgis-", "")) {
  const { lang, t9nLocale } = getElementLocales(element);
  const t9nAssetsPath = `${assetsPath}/${assetName}/t9n`;
  const prefix = `${assetName}.t9n.`;
  const t9nStrings = await fetchT9NStringsBundle(t9nLocale, t9nAssetsPath, prefix);
  return { lang, t9nLocale, t9nStrings };
}

// src/types.ts
var controllerSymbol = Symbol("controller");

// src/utils.ts
function extendObject(base, extend) {
  Object.entries(extend).forEach(([key, value]) => {
    if (key in base)
      throw new Error(`Unable to extend object because property "${key}" is already defined`);
    const thisBase = base;
    thisBase[key] = value;
  });
  return base;
}
var isController = (value) => typeof value === "object" && value !== null && (controllerSymbol in value || "hostConnected" in value || "hostDisconnected" in value || "hostUpdate" in value || "hostUpdated" in value);

// src/ControllerInternals.ts
var ControllerInternals = class {
  constructor() {
    this._ambientControllers = [];
    /**
     * The type definition has to be duplicated due to the
     * "'use' is referenced directly or indirectly in its own type annotation."
     * error
     */
    this.use = async (value, watchExports) => {
      const controller = this._useRefSync(value);
      if (controller === void 0) {
        if (typeof watchExports === "function") {
          const error = new Error(
            `Unable to resolve a controller from the provided value, so can't watch it's exports. ${unresolvableExports}`
          );
          console.error(error);
        }
        return value;
      }
      await controller.ready;
      if (typeof watchExports === "function") {
        if (controller.watchExports === void 0)
          throw new Error(`The controller must implement watchExports method to support watching exports`);
        const unsubscribe = controller.watchExports(
          (exports) => watchExports(exports, unsubscribe)
        );
      }
      return controller.exports;
    };
    this.useRef = async (value) => {
      const controller = this._useRefSync(value);
      if (controller === void 0)
        throw new Error(`Unable to resolve a controller from the provided value. ${unresolvableExports}`);
      await controller.ready;
      return controller;
    };
    this.shouldBypassSetter = false;
    this.shouldBypassGetter = false;
    this.shouldBypassReadonly = false;
    /**
     * A map from component instance or component element to component instance.
     * To get from component instance or component element to component element,
     * you can just use the .el property
     */
    this.elementToInstance = /* @__PURE__ */ new WeakMap();
  }
  /*
   * Allow controllers to implicitly retrieve which component they are in, to
   * improve DX (avoids the need to pass "this" explicitly for each controller)
   */
  setAmbientComponent(component) {
    if (this._ambientComponent === component)
      return;
    this._ambientComponent = component;
    queueMicrotask(() => {
      if (this._ambientComponent === component)
        this._ambientComponent = void 0;
    });
  }
  retrieveComponent(name) {
    if (this._ambientComponent === void 0)
      throw new Error(
        [
          `Unable to find out which component ${name || "this"} controller `,
          "belongs to. This might happen if you tried to create a controller ",
          "outside the component. If so, please wrap your controller ",
          "definition in an arrow function, ",
          "`const myController = ()=>makeController(...);` and call that",
          "function inside the component `my = myController();`, or ",
          "define your controller using makeGenericController/GenericController ",
          "instead.\n",
          "If you wish to use a controller inside an async controller, ",
          "make sure you are using controller.use.\n",
          "You might also have multiple instances of Controllers loaded"
        ].join("\n")
      );
    return this._ambientComponent;
  }
  /*
   * Aids proxyExports() in knowing who is it's host
   */
  setParentController(controller) {
    if (controller === void 0) {
      this._ambientControllers = [];
      return;
    }
    const index = this._ambientControllers.indexOf(controller);
    this._ambientControllers = index === -1 ? [...this._ambientControllers, controller] : this._ambientControllers.slice(0, index + 1);
    queueMicrotask(() => {
      this._ambientControllers = [];
    });
  }
  retrieveParentControllers() {
    return this._ambientControllers;
  }
  /*
   * Aids controller.use in retrieving controller value when it receives
   * controller exports, rather than the controller itself
   */
  setAmbientChildController(controller) {
    if (this._ambientChildController === controller)
      return;
    this._ambientChildController = controller;
    queueMicrotask(() => {
      if (this._ambientChildController === controller)
        this._ambientChildController = void 0;
    });
  }
  retrieveAmbientChildController() {
    const controller = this._ambientChildController;
    this._ambientChildController = void 0;
    return controller;
  }
  /**
   * Try to resolve a controller, without awaiting it's load
   */
  _useRefSync(value) {
    const ambientChildController = this.retrieveAmbientChildController();
    if (ambientChildController !== void 0)
      return ambientChildController;
    const component = Controller.internals.retrieveComponent();
    const controller = component.manager.internals.resolveExports(value);
    if (controller !== void 0)
      return controller;
    if (isController(value))
      return value;
    return void 0;
  }
};
var unresolvableExports = [
  "The value you passed is not a controller and not a controller exports. If ",
  "your controller exports a literal value, try making your controller export ",
  "an object instead"
].join("");

// src/Controller.ts
var _a;
var _Controller = class _Controller {
  constructor(component) {
    this._ready = new Deferred();
    this._lifecycleDisconnected = [];
    this.connectedCalled = false;
    this.willLoadCalled = false;
    this.didLoadCalled = false;
    this[_a] = true;
    this.ready = this._ready.promise;
    /*
     * Setting default exports to "this" so that controllers that don't use
     * exports/proxyExports(), could still be used as if they did
     * (i.e with controller.use)
     */
    this._exports = makeProvisionalValue(this);
    this._exportWatchers = /* @__PURE__ */ new Set();
    const resolvedComponent = toControllerHost(
      component ?? _Controller.internals.retrieveComponent(new.target.name)
    );
    Object.defineProperty(this, "component", {
      writable: false,
      enumerable: false,
      configurable: true,
      value: resolvedComponent
    });
    this.component.addController(this);
    const manager = this.component.manager;
    this.connected = manager?.connected;
    this.internals = manager?.internals;
    _Controller.internals.setParentController(this);
    if ("hostDestroy" in this)
      this.component.manager.ensureHasDestroy();
    if (manager !== void 0)
      queueMicrotask(() => this.catchUpLifecycle());
    const controller = this;
    this._callbacks = {
      hostConnected: "hostConnected" in this ? [() => controller.hostConnected?.()] : [],
      hostDisconnected: "hostDisconnected" in this ? [() => controller.hostDisconnected?.()] : [],
      hostLoad: "hostLoad" in this ? [() => controller.hostLoad?.()] : [],
      hostLoaded: "hostLoaded" in this ? [() => controller.hostLoaded?.()] : [],
      hostRender: "hostRender" in this ? [() => controller.hostRender?.()] : [],
      hostRendered: "hostRendered" in this ? [() => controller.hostRendered?.()] : [],
      hostUpdate: "hostUpdate" in this ? [() => controller.hostUpdate?.()] : [],
      hostUpdated: "hostUpdated" in this ? [() => controller.hostUpdated?.()] : [],
      hostDestroy: "hostDestroy" in this ? [() => controller.hostDestroy?.()] : [],
      hostLifecycle: "hostLifecycle" in this ? [() => controller.hostLifecycle?.()] : []
    };
  }
  /**
   * If controller is being added dynamically, after the component
   * construction, then trigger connected and load right away
   */
  catchUpLifecycle() {
    if (this.connectedCalled)
      return;
    this.triggerConnected();
    const loadWillStillHappen = !this.component.manager.willLoadCalled;
    if (loadWillStillHappen)
      return;
    this.triggerLoad().then(() => {
      const loadedWillStillHappen = !this.component.manager.didLoadCalled;
      if (loadedWillStillHappen)
        return;
      this.triggerLoaded();
    }).catch(console.error);
  }
  get exports() {
    return this._exports;
  }
  /**
   * Set controller's exports property (for usage with proxyExports()) and mark
   * controller as ready (for usage in other controllers). Also, triggers
   * re-render of the component
   */
  set exports(exports) {
    if (this._exports !== exports) {
      this._exports = exports;
      if (this.connectedCalled)
        this.component.requestUpdate();
      this._exportWatchers.forEach((callback) => callback(exports));
    }
    this._ready.resolve(exports);
  }
  setProvisionalExports(exports) {
    this._exports = makeProvisionalValue(exports);
    this._exportWatchers.forEach((callback) => callback(this._exports));
  }
  watchExports(callback) {
    const safeCallback = (exports) => safeCall(() => callback(exports));
    this._exportWatchers.add(safeCallback);
    return () => void this._exportWatchers.delete(safeCallback);
  }
  /**
   * A flexible utility for making sure a controller is loaded before it's used,
   * regardless of how or where a controller was defined:
   *
   * @example
   * makeGenericController(async (component, controller) => {
   *   // Await some controller from the component:
   *   await controller.use(component.someController);
   *   // Initialize new controllers
   *   await controller.use(load(importCoreReactiveUtils));
   *   await controller.use(new ViewModelController(component,newWidgetsHomeHomeViewModel));
   *   await controller.use(someController(component));
   * });
   *
   * @remarks
   * If your controller is not async, and you are not creating it async, then
   * you are not required to use controller.use - you can use it directly.
   * Similarly, accessing controllers after componentWillLoad callback does not
   * require awaiting them as they are guaranteed to be loaded by then.
   */
  get use() {
    _Controller.internals.setAmbientComponent(this.component);
    return _Controller.internals.use;
  }
  /**
   * Just like controller.use, but returns the controller itself, rather than it's
   * exports
   *
   * Use cases:
   * - You have a controller and you want to make sure it's loaded before you
   *   try to use it
   * - Your controller is not using exports, so you wish to access some props on
   *   it directly
   * - You have a controller exports only, and you want to retrieve the
   *   controller itself. This is useful if you wish to call .watchExports() or
   *   some other method on the controller
   */
  get useRef() {
    _Controller.internals.setAmbientComponent(this.component);
    return _Controller.internals.useRef;
  }
  /**
   * If you need to set a prop/state without triggering the custom setter you
   * defined with getSet()/dynamicGetSet()/readonly(), set the value inside
   * of this function
   *
   * @example
   * @Prop() readOnly = this.manager.readOnly(true);
   *
   * someAction(): void {
   *   this.manager.bypassSetter(()=>{
   *     this.readOnly = false;
   *   });
   * }
   *
   */
  bypassSetter(callback) {
    _Controller.internals.shouldBypassSetter = true;
    try {
      return callback();
    } finally {
      _Controller.internals.shouldBypassSetter = false;
    }
  }
  /**
   * Like bypassSetter, but only bypasses this.manager.readonly(), rather that
   * all setters set using this.manager.getSet()
   */
  bypassReadonly(callback) {
    _Controller.internals.shouldBypassReadonly = true;
    try {
      return callback();
    } finally {
      _Controller.internals.shouldBypassReadonly = false;
    }
  }
  /**
   * Property reads inside of this function will bypass any custom getter you
   * may have, and read the value directly from what's stored in Stencil.
   *
   * This also bypasses reactiveUtils integration - reading a property inside of
   * bypassGetter won't make that property tracked.
   *
   * @example
   * reactiveUtils.watch(
   *   ()=>{
   *     this.manager.bypassGetter(()=>{
   *       console.log(this.someProp);
   *     });
   *     return this.prop;
   *   },
   *   console.log
   * )
   */
  bypassGetter(callback) {
    _Controller.internals.shouldBypassGetter = true;
    try {
      return callback();
    } finally {
      _Controller.internals.shouldBypassGetter = false;
    }
  }
  /**
   * Like this.manager.getSet(), but can be called on any component's
   * state/prop from anywhere, rather than just from the default value
   */
  dynamicGetSet(name, getSet) {
    this.genericGetSet(name, getSet);
  }
  /**
   * Like dynamicGetSet, but less type-safe. Useful in cases when trying to set
   * getters/setters in place where property names & types are not known
   * statically
   */
  genericGetSet(property, getSet) {
    var _a2, _b;
    const genericGetSet = getSet;
    if (genericGetSet.get !== void 0) {
      (_a2 = this.internals.getters)[property] ?? (_a2[property] = []);
      this.internals.getters[property].unshift(genericGetSet.get);
    }
    if (genericGetSet.set !== void 0) {
      (_b = this.internals.setters)[property] ?? (_b[property] = []);
      this.internals.setters[property].unshift(genericGetSet.set);
    }
  }
  // FEATURE: improve typings
  /**
   * Dynamically set a watcher for any \@Prop()/\@State() property
   */
  watch(property, callback) {
    var _a2;
    const type = getMemberType(this.component, property);
    if (type === void 0)
      throw new Error(
        `Trying to watch a non-@Prop, non-@State property "${property}". Either convert it into a @State() or use manager.getSet/dynamicGetSet`
      );
    (_a2 = this.internals.allWatchers)[property] ?? (_a2[property] = []);
    const watchers = this.internals.allWatchers[property];
    const genericCallback = callback;
    const safeCallback = (newValue, oldValue, propertyName) => safeCall(() => genericCallback(newValue, oldValue, propertyName));
    watchers.push(safeCallback);
    return () => {
      const index = watchers.indexOf(safeCallback);
      if (index !== -1)
        watchers.splice(index, 1);
    };
  }
  // Register a lifecycle callback
  onConnected(callback) {
    this._callbacks.hostConnected.push(callback);
  }
  onDisconnected(callback) {
    this._callbacks.hostDisconnected.push(callback);
  }
  onLoad(callback) {
    this._callbacks.hostLoad.push(callback);
  }
  onLoaded(callback) {
    this._callbacks.hostLoaded.push(callback);
  }
  onRender(callback) {
    this._callbacks.hostRender.push(callback);
  }
  onRendered(callback) {
    this._callbacks.hostRendered.push(callback);
  }
  onUpdate(callback) {
    this._callbacks.hostUpdate.push(callback);
  }
  onUpdated(callback) {
    this._callbacks.hostUpdated.push(callback);
  }
  onDestroy(callback) {
    this.component.manager.ensureHasDestroy();
    this._callbacks.hostDestroy.push(callback);
  }
  onLifecycle(callback) {
    this._callbacks.hostLifecycle.push(callback);
    if (this.connectedCalled && this.component.el.isConnected)
      this._callLifecycle(callback);
  }
  // Call each lifecycle hook
  triggerConnected() {
    this._callbacks.hostConnected.forEach(safeCall);
    this.triggerLifecycle();
    this.connectedCalled = true;
  }
  triggerDisconnected() {
    this._callbacks.hostDisconnected.forEach(safeCall);
    this._lifecycleDisconnected.forEach(safeCall);
    this._lifecycleDisconnected = [];
  }
  async triggerLoad() {
    if (this.willLoadCalled)
      return;
    this.willLoadCalled = true;
    if (this._callbacks.hostLoad.length > 0)
      await Promise.allSettled(this._callbacks.hostLoad.map(safeAsyncCall));
    this._ready.resolve(this._exports);
  }
  triggerLoaded() {
    if (this.didLoadCalled)
      return;
    this._callbacks.hostLoaded.forEach(safeCall);
    this.didLoadCalled = true;
  }
  async triggerRender() {
    if (this._callbacks.hostRender.length > 0)
      await Promise.allSettled(this._callbacks.hostRender.map(safeAsyncCall));
  }
  triggerRendered() {
    this._callbacks.hostRendered.forEach(safeCall);
  }
  async triggerUpdate() {
    if (this._callbacks.hostUpdate.length > 0)
      await Promise.allSettled(this._callbacks.hostUpdate.map(safeAsyncCall));
  }
  triggerUpdated() {
    this._callbacks.hostUpdated.forEach(safeCall);
  }
  triggerDestroy() {
    this._callbacks.hostDestroy.forEach(safeCall);
  }
  triggerLifecycle() {
    this._callbacks.hostLifecycle.forEach((callback) => this._callLifecycle(callback));
  }
  _callLifecycle(callback) {
    const cleanupRaw = safeCall(callback);
    const cleanup = Array.isArray(cleanupRaw) ? cleanupRaw : [cleanupRaw];
    cleanup.forEach((cleanup2) => {
      if (typeof cleanup2 === "function")
        this._lifecycleDisconnected.push(cleanup2);
      else if (typeof cleanup2 === "object" && typeof cleanup2.remove === "function")
        this._lifecycleDisconnected.push(cleanup2.remove);
    });
  }
};
_a = controllerSymbol;
_Controller.internals = new ControllerInternals();
var Controller = _Controller;
var GenericController = class extends Controller {
  // Redundant constructor needed to improve typing
  constructor(component) {
    super(component);
  }
  // Overriding super's watch only to improve typing
  watch(property, callback) {
    return super.watch(
      property,
      callback
    );
  }
  /**
   * Silence "Property 'dynamicGetSet' in type
   * 'GenericController<Exports, Requires>' is not assignable to the same
   * property in base type 'Controller<Exports>'", as TypeScript is being overly
   * conservative here with what it allows
   */
  dynamicGetSet(property, getSet) {
    super.genericGetSet(property, getSet);
  }
};
function makeProvisionalValue(base) {
  if (typeof base !== "object" && typeof base !== "function" || base === null)
    return base;
  const proxy3 = new Proxy(base, {
    get(target, prop, receiver) {
      if (cyclical.has(prop) && prop in target && target[prop] === proxy3)
        return void 0;
      if (prop in target || prop in Promise.prototype || typeof prop === "symbol")
        return typeof target === "function" ? target[prop] : Reflect.get(target, prop, receiver);
      console.error(`Trying to access "${prop.toString()}" on the controller before it's loaded. ${accessBeforeLoad}`);
      return void 0;
    },
    set(target, prop, newValue, receiver) {
      console.error(`Trying to set "${prop.toString()}" on the controller before it's loaded. ${accessBeforeLoad}`);
      return Reflect.set(target, prop, newValue, receiver);
    }
  });
  return proxy3;
}
var cyclical = /* @__PURE__ */ new Set(["exports", "_exports"]);
var accessBeforeLoad = [
  "This might be the case if you are trying to access an async controller in ",
  "connectedCallback(). Or, if you are using it inside of ",
  "componentWillLoad()/another controller without controller.use. Example correct ",
  "usage:\n",
  "makeController(async (component, controller)=>{ await controller.use(someOtherController); });"
].join("");
function toControllerHost(component) {
  if ("addController" in component)
    return component;
  else
    throw new Error(
      "Component does not implement ControllerHost. This might be because you forgot to add 'manager: Controller<this> = useControllerManager(this);' in your component, or you tried to use some controller before that line"
    );
}

// src/trackPropertyKey.ts
function trackPropertyKey(object, onResolved, defaultValue) {
  const keys = Object.keys(object);
  const keyCount = keys.length;
  if (keyTrackMap === void 0)
    queueMicrotask(keyTrackResolve);
  keyTrackMap ?? (keyTrackMap = /* @__PURE__ */ new Map());
  let pendingTrackers = keyTrackMap.get(object);
  if (pendingTrackers === void 0) {
    pendingTrackers = { callbacks: [], keyCount };
    keyTrackMap.set(object, pendingTrackers);
  }
  if (pendingTrackers.keyCount !== keyCount) {
    pendingTrackers.callbacks.forEach((resolve) => resolve(keys));
    pendingTrackers.callbacks = [];
    pendingTrackers.keyCount = keyCount;
  }
  pendingTrackers.callbacks.push((keys2) => {
    const callback = (key2) => safeCall(() => onResolved(key2));
    const key = keys2[keyCount];
    if (key === void 0)
      callback(void 0);
    else if (object[key] === defaultValue)
      callback(key);
    else
      callback(void 0);
  });
  return defaultValue;
}
var keyTrackMap = void 0;
function keyTrackResolve() {
  Array.from(keyTrackMap?.entries() ?? []).forEach(([object, { callbacks }]) => {
    const keys = Object.keys(object);
    callbacks.forEach((commit) => commit(keys));
  });
  keyTrackMap = void 0;
}

// src/ComponentInternals.ts
var ComponentInternals = class {
  constructor(component) {
    /**
     * When watchers are set, set then into `allWatchers`. When watchers are read
     * in the setter, read from `enabledWatchers`.
     * On connectedCallback(), controller manager does `enabledWatchers=allWatchers`.
     * Reasoning:
     * - This disables watchers until connected callback (matches behavior of
     *   Stencil's watchers)
     * - This removes in the setter to check if watchers were enabled already or
     *   not (as getters/setters are hot path, and should be streamlined)
     */
    this.enabledWatchers = {};
    this.allWatchers = {};
    this.trackKey = (hostsCandidates, onResolved, defaultValue) => {
      const candidateHosts = Array.isArray(hostsCandidates) ? hostsCandidates : [hostsCandidates];
      let leftToResolve = candidateHosts.length + 1;
      const resolved = (resolution) => {
        leftToResolve -= 1;
        if (resolution !== void 0)
          leftToResolve = 0;
        if (leftToResolve === 0)
          onResolved(resolution);
      };
      candidateHosts.forEach(
        (host) => this.component.manager.trackPropertyKey(
          host,
          (key) => resolved(
            key === void 0 ? void 0 : {
              key,
              host,
              type: "property",
              domValue: void 0
            }
          ),
          defaultValue
        )
      );
      this.component.manager.trackPropKey((key, domValue) => {
        const propType = key === void 0 ? void 0 : getPropType(this.component, key);
        resolved(
          key === void 0 ? void 0 : {
            key,
            host: this.component,
            type: propType ?? "prop",
            domValue: propType === "prop" ? domValue : void 0
          }
        );
      }, defaultValue);
      return defaultValue;
    };
    this.trackPropKey = (onResolved, defaultValue, ignoreDefaultValueMismatch = false) => {
      if (this._trackedValue !== nothing && this._trackedValue !== defaultValue)
        this._firePropertyTrackers(void 0, void 0, void 0);
      if (this._keyTrackers.length === 0)
        queueMicrotask(() => this._firePropertyTrackers(void 0, void 0, void 0));
      this._trackedValue = defaultValue;
      this._keyTrackers.push(
        (key, value, previousValue) => safeCall(
          () => onResolved(defaultValue === value || ignoreDefaultValueMismatch ? key : void 0, previousValue)
        )
      );
      return defaultValue;
    };
    this._trackedValue = nothing;
    this._keyTrackers = [];
    this.getters = {};
    this.setters = {};
    this.accessorGetter = {};
    this.accessorSetter = {};
    this._exports = /* @__PURE__ */ new WeakMap();
    Object.defineProperty(this, "component", {
      writable: false,
      enumerable: false,
      configurable: true,
      value: component
    });
  }
  _firePropertyTrackers(key, value, oldValue) {
    const trackers = this._keyTrackers;
    this._trackedValue = nothing;
    this._keyTrackers = [];
    trackers.forEach((tracker) => tracker(key, value, oldValue));
  }
  /**
   * Configure a getter or setter for a given \@Prop/\@State
   *
   * Note, since props are defined on the prototype, they are shared between all
   * instances of a component. Thus, instead of passing a reference to the
   * getter/setter function, you should update the
   * ComponentInternals.getters/setters properties, and then call getSetProxy
   * to apply the changes to the prototype
   */
  getSetProxy(property, hasGetter, hasSetter) {
    const classPrototype = Object.getPrototypeOf(this.component);
    this._getSetProxy(classPrototype, property, hasGetter, hasSetter, "class");
    const htmlPrototype = Object.getPrototypeOf(this.component.el);
    if (classPrototype !== htmlPrototype)
      this._getSetProxy(htmlPrototype, property, hasGetter, hasSetter, "html");
  }
  _getSetProxy(prototype, name, hasGetter, hasSetter, type) {
    const component = this.component;
    const propType = getMemberType(component, name);
    const descriptor = Object.getOwnPropertyDescriptor(prototype, name);
    const tolerateNotFound = type === "html";
    if (descriptor?.set === void 0 || descriptor.get === void 0)
      if (descriptor !== void 0 && "value" in descriptor)
        throw new Error(
          `getSet() should only be used on Stencil's @Prop and @State properties. For internal component properties, use regular get/set syntax. Tried to use it on "${name}" in ${component.el.tagName}`
        );
      else if (tolerateNotFound)
        return;
      else
        throw new Error(`Unable to find "${name}" property on the ${component.el.tagName} component`);
    const { get: originalGet, set: originalSet } = descriptor;
    const isGetterAlreadyOverwritten = customAccessor in originalGet;
    const isSetterAlreadyOverwritten = customAccessor in originalSet;
    const shouldOverwriteGet = !isGetterAlreadyOverwritten && hasGetter;
    const shouldOverwriteSet = !isSetterAlreadyOverwritten && hasSetter;
    if (!shouldOverwriteGet && !shouldOverwriteSet)
      return;
    const finalGetter = shouldOverwriteGet ? function getter() {
      let value = originalGet.call(this);
      const component2 = Controller.internals.elementToInstance.get(this);
      if (Controller.internals.shouldBypassGetter || component2 === void 0)
        return value;
      const internals = component2.manager.internals;
      value = internals.accessorGetter[name](value, name);
      const getters = internals.getters[name] ?? emptyArray;
      for (let i = 0; i < getters.length; i++)
        value = getters[i](value, name);
      return value;
    } : originalGet;
    const finalSetter = shouldOverwriteSet ? function setter(rawNewValue) {
      const oldValue = originalGet.call(this);
      let newValue = parsePropertyValue(rawNewValue, propType);
      const component2 = Controller.internals.elementToInstance.get(this);
      if (component2 === void 0) {
        originalSet.call(this, rawNewValue);
        return;
      }
      const internals = component2.manager.internals;
      if (newValue === oldValue)
        originalSet.call(this, rawNewValue);
      else {
        const setters = Controller.internals.shouldBypassSetter ? emptyArray : internals.setters[name] ?? emptyArray;
        for (let i = 0; i < setters.length; i++)
          newValue = setters[i](newValue, oldValue, name);
        newValue = internals.accessorSetter[name](newValue, oldValue, name);
        originalSet.call(this, newValue);
        if (newValue !== oldValue)
          internals.enabledWatchers[name]?.forEach((watcher) => watcher(newValue, oldValue, name));
      }
      if (internals._keyTrackers.length > 0)
        internals?._firePropertyTrackers(name, rawNewValue, oldValue);
    } : originalSet;
    if (shouldOverwriteGet)
      Object.defineProperty(finalGetter, customAccessor, { value: true });
    if (shouldOverwriteSet)
      Object.defineProperty(finalSetter, customAccessor, { value: true });
    Object.defineProperty(prototype, name, {
      ...descriptor,
      get: finalGetter,
      set: finalSetter
    });
  }
  /**
   * Associate an exports object with a controller for reverse lookup in
   * controller.use
   */
  markExports(controller, exports) {
    if (typeof exports === "object" && exports !== null || typeof exports === "function")
      this._exports.set(exports, controller);
  }
  resolveExports(exports) {
    if (typeof exports === "object" && exports !== null || typeof exports === "function")
      return this._exports.get(exports);
    else
      return void 0;
  }
};
var emptyArray = [];
var customAccessor = Symbol("controllersCustomAccessor");
var nothing = Symbol("nothing");
var accessorPromise = Promise.all([(0,_index_0bc55ca5_js__WEBPACK_IMPORTED_MODULE_1__.l)(), (0,_index_0bc55ca5_js__WEBPACK_IMPORTED_MODULE_1__.m)()]);
function reactiveUtilsIntegration(component) {
  const members = getPropLikeMembers(component);
  const internals = component.manager.internals;
  members.forEach((name) => {
    internals.accessorGetter[name] = defaultGetterSetter;
    internals.accessorSetter[name] = defaultGetterSetter;
    internals.getSetProxy(name, true, true);
  });
  return async (enabledMembers = members) => {
    const [Accessor, { subclass, property }] = await accessorPromise;
    class AccessorSubclass extends Accessor {
    }
    const getter = (_value, propertyName) => accessor[propertyName];
    function setter(newValue, _oldValue, propertyName) {
      if (accessor !== void 0)
        accessor[propertyName] = newValue;
      return newValue;
    }
    component.manager.bypassGetter(
      () => enabledMembers.forEach((name) => {
        internals.accessorGetter[name] = getter;
        internals.accessorSetter[name] = setter;
        property({
          value: component[name]
        })(AccessorSubclass.prototype, name);
      })
    );
    const Subclass = subclass(component.el.tagName)(AccessorSubclass);
    const accessor = new Subclass();
  };
}
var defaultGetterSetter = (value) => value;

// src/ControllerManager.ts
var useControllerManager = (component) => new ControllerManager(component);
var ControllerManager = class extends GenericController {
  constructor(component) {
    const controllers = /* @__PURE__ */ new Set();
    const controllerHost = {
      addController: (controller) => {
        controllers.add(controller);
      },
      removeController: (controller) => {
        controllers.delete(controller);
      },
      requestUpdate: () => (0,_index_6e172aac_js__WEBPACK_IMPORTED_MODULE_0__.f)(component)
    };
    extendObject(component, controllerHost);
    super(component);
    this._connected = new Deferred();
    this.internals = new ComponentInternals(this.component);
    this.connected = this._connected.promise;
    this.hasDestroy = false;
    this.destroyed = false;
    this._updatePromise = new Deferred();
    this._originalLifecycles = {};
    /**
     * A magical solution to finding out what property name a given controller
     * on a given object was assigned to. Note, this does not work for properties
     * that have \@Prop() or \@State() decorator - for those, use
     * manager.trackPropKey() instead.
     *
     * @example
     * function trackMe<T>(defaultValue:T, component:BaseComponent):T {
     *   component.manager.trackPropertyKey(component, (key)=>console.log(key), defaultValue);
     *   return defaultValue;
     * }
     *
     * class MyComponent extends BaseComponent {
     *   // Will console log "myProp"
     *   myProp = trackMe('a', this);
     * }
     *
     */
    this.trackPropertyKey = trackPropertyKey;
    /**
     * Like manager.trackPropertyKey(), but for props that have \@State() or \@Prop()
     * decorator
     *
     * @example
     * function trackMe(component:BaseComponent) {
     *   component.manager.trackPropKey((key)=>console.log(key));
     * }
     *
     * class MyComponent extends BaseComponent {
     *   // Will console log "myProp"
     *   @Prop() myProp = trackMe(this);
     *
     *   // Will console log "myState"
     *   @State() myState = trackMe(this);
     * }
     */
    this.trackPropKey = this.internals.trackPropKey;
    /**
     * A combination of trackPropertyKey() and trackPropKey(). For usage when
     * you want to track a property, but don't know if it will be defined with the
     * \@Prop() decorator or not
     */
    this.trackKey = this.internals.trackKey;
    this._readonlySetter = (newValue, _oldValue, property) => {
      if (Controller.internals.shouldBypassReadonly)
        return newValue;
      const isProp = getPropType(this.component, property) === "prop";
      if (isProp)
        (0,_index_6e172aac_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.component);
      throw new Error(
        `Cannot assign to read-only property "${property}" of ${this.component.el.tagName.toLowerCase()}. Trying to assign "${String(
          newValue
        )}"`
      );
    };
    /**
     * In development, on hot module reload, controller would be re-initialized
     * with all Props and State values persistent, but properties lost. This unsafe
     * development-only API lets you set or get data for a controller that would
     * persist across hot reloads.
     */
    this.devOnlySetPersistentControllerData = void 0 ;
    this.devOnlyGetPersistentControllerData = void 0 ;
    this.component.manager = this;
    retrieveComponentMeta(component);
    this._controllers = controllers;
    this.exports = void 0;
    this.hasDestroy = "preserveOnDisconnect" in this.component && typeof this.component.destroy === "function";
    if (this.hasDestroy)
      this.watch("preserveOnDisconnect", () => this._preserveOnDisconnectWatcher());
    this._bindLifecycleMethods();
    Object.defineProperty(component, "updateComplete", {
      get: async () => await this._updatePromise.promise
    });
    this.internals.reactiveUtilsIntegration = reactiveUtilsIntegration(this.component);
    Controller.internals.setParentController(void 0);
    Controller.internals.setAmbientComponent(component);
    Controller.internals.elementToInstance.set(component.el, component);
    Controller.internals.elementToInstance.set(component, component);
  }
  _bindLifecycleMethods() {
    const component = this.component;
    this._originalLifecycles = {
      connectedCallback: component.connectedCallback,
      disconnectedCallback: component.disconnectedCallback,
      componentWillLoad: component.componentWillLoad,
      componentDidLoad: component.componentDidLoad,
      componentWillRender: component.componentWillRender,
      componentDidRender: component.componentDidRender,
      componentWillUpdate: component.componentWillUpdate,
      componentDidUpdate: component.componentDidUpdate,
      destroy: component.destroy
    };
    component.connectedCallback = this._connectedCallback.bind(this);
    component.disconnectedCallback = this._disconnectedCallback.bind(this);
    component.componentWillLoad = this._componentWillLoad.bind(this);
    component.componentDidLoad = this._componentDidLoad.bind(this);
    component.componentWillRender = this._componentWillRender.bind(this);
    component.componentDidRender = this._componentDidRender.bind(this);
    component.componentWillUpdate = this._componentWillUpdate.bind(this);
    component.componentDidUpdate = this._componentDidUpdate.bind(this);
    if (this.hasDestroy)
      component.destroy = this.destroy.bind(this);
  }
  /**
   * Throws an error if component does not implement destroy() lifecycle, but
   * tries to use it.
   */
  ensureHasDestroy() {
    if (!this.hasDestroy)
      throw new Error(destroyErrorMessage);
  }
  /**
   * Private because this is not supposed to be called by Component directly.
   * Instead, _bindLifecycleMethods will take care of that. Otherwise, you risk
   * calling lifecycle methods twice.
   */
  _connectedCallback() {
    if (this.destroyed) {
      const tagName = this.component.el.tagName.toLowerCase();
      this.component.el.remove();
      throw new Error(
        `The ${tagName} component has already been destroyed. It can not be used again. If you meant to disconnect and reconnect a component without automatic destroy, set the preserveOnDisconnect prop.`
      );
    }
    this.internals.enabledWatchers = this.internals.allWatchers;
    keyTrackResolve();
    this._connected.resolve();
    this._controllers.forEach(
      (controller) => "triggerConnected" in controller ? controller.triggerConnected() : safeCall(() => controller.hostConnected?.())
    );
    this._originalLifecycles.connectedCallback?.call(this.component);
  }
  _disconnectedCallback() {
    if (this.destroyed)
      return;
    this._controllers.forEach(
      (controller) => "triggerDisconnected" in controller ? controller.triggerDisconnected() : safeCall(() => controller.hostDisconnected?.())
    );
    this._originalLifecycles.disconnectedCallback?.call(this.component);
    if (this.hasDestroy)
      this._preserveOnDisconnectWatcher();
  }
  async _componentWillLoad() {
    await this.internals.reactiveUtilsIntegration();
    await Promise.allSettled(
      Array.from(
        this._controllers,
        async (controller) => "triggerLoad" in controller ? await controller.triggerLoad() : await safeAsyncCall(async () => await controller.hostLoad?.())
      )
    );
    await this._originalLifecycles.componentWillLoad?.call(this.component);
  }
  _componentDidLoad() {
    this._controllers.forEach(
      (controller) => "triggerLoaded" in controller ? controller.triggerLoaded() : safeCall(() => controller.hostLoaded?.())
    );
    this._originalLifecycles.componentDidLoad?.call(this.component);
  }
  async _componentWillRender() {
    await Promise.allSettled(
      Array.from(
        this._controllers,
        async (controller) => "triggerRender" in controller ? await controller.triggerRender() : await safeAsyncCall(async () => await controller.hostRender?.())
      )
    );
    await this._originalLifecycles.componentWillRender?.call(this.component);
  }
  _componentDidRender() {
    this._controllers.forEach(
      (controller) => "triggerRendered" in controller ? controller.triggerRendered() : safeCall(() => controller.hostRendered?.())
    );
    this._originalLifecycles.componentDidRender?.call(this.component);
  }
  async _componentWillUpdate() {
    await Promise.allSettled(
      Array.from(
        this._controllers,
        async (controller) => "triggerUpdate" in controller ? await controller.triggerUpdate() : await safeAsyncCall(async () => await controller.hostUpdate?.())
      )
    );
    await this._originalLifecycles.componentWillUpdate?.call(this.component);
  }
  _componentDidUpdate() {
    this._controllers.forEach(
      (controller) => "triggerUpdated" in controller ? controller.triggerUpdated() : safeCall(() => controller.hostUpdated?.())
    );
    this._originalLifecycles.componentDidUpdate?.call(this.component);
    const updatePromise = this._updatePromise;
    this._updatePromise = new Deferred();
    updatePromise.resolve(true);
  }
  async destroy() {
    this.ensureHasDestroy();
    if (this.destroyed)
      return;
    if (this.component.el.isConnected) {
      this.hasDestroy = false;
      this.component.el.remove();
      this.hasDestroy = true;
    }
    this.destroyed = true;
    this._controllers.forEach(
      (controller) => "triggerDestroy" in controller ? controller.triggerDestroy() : safeCall(() => controller.hostDestroy?.())
    );
    await this._originalLifecycles.destroy?.call(this.component);
  }
  _preserveOnDisconnectWatcher() {
    if (!this.component.el.isConnected && !this.component.preserveOnDisconnect)
      void this.destroy().catch(console.error);
  }
  /**
   * Make a @Prop() or @State() readonly (prevent overwriting default value).
   *
   * For internal properties, prefer TypeScript's "readonly" modifier instead.
   *
   * @example
   * // Defining readonly prop
   * @Prop({ reflect: true }) prop = this.manager.readonly('a');
   *
   * @example
   * // Overwriting readonly prop internally
   * this.manager.bypassReadonly(()=>{
   *   this.prop = 'b';
   * });
   *
   */
  readonly(value) {
    return this.getSet(value, { set: this._readonlySetter });
  }
  /**
   * Listen for any component's @State()/@Prop() change, and mutate it's
   * value before it is set.
   * This is necessary because Stencil's Compiler does not support get/set for
   * @State()/@Prop().
   * For private component properties, you should use regular get/set syntax.
   *
   * @example
   * @Prop() exampleProp = this.manager.getSet(defaultValue,{get,set})
   * @Prop() someProp = this.manager.getSet(
   *   undefined as string | undefined,
   *   {
   *     get: (value)=>value.trim(),
   *     set: (newValue,oldValue) => newValue.trim() ?? oldValue
   *   }
   * )
   *
   * @remarks
   * Unlike a native get/set, the get function receives the current attribute
   * value, and can modify it before returning it (or can disregard the current
   * value and get it from elsewhere instead).
   * Similarly, setter is called with the new and old value, and is expected to
   * return the final new value (or return the old value to undo the change)
   */
  getSet(defaultValue, getSet) {
    return this.component.manager.trackPropKey((name) => {
      var _a2;
      if (name === void 0)
        throw new Error(
          "Unable to resolve get/set's prop name. Make sure you are using it like @Prop() someProp = this.manager.getSet(defaultValue,{get,set})"
        );
      if (getSet.set === this._readonlySetter) {
        (_a2 = this.internals).readonlyProps ?? (_a2.readonlyProps = /* @__PURE__ */ new Set());
        this.internals.readonlyProps.add(name);
      }
      const genericComponent = this.component;
      const value = genericComponent[name];
      if (value != null && value !== defaultValue && typeof getSet.set === "function" && getSet.initialSet !== false) {
        const newValue = getSet.set(value, defaultValue, name);
        if (newValue !== value)
          genericComponent[name] = newValue;
      }
      this.genericGetSet(name, getSet);
    }, defaultValue);
  }
};
var destroyErrorMessage = `
If the component uses a controller that uses destroy() method, then the
component must have the following properties:
${// Don't expose internal code in production, and keep bundle smaller:
`preserveOnDisconnect and destroy` }
`.trim();

// src/proxyExports.ts
var proxyExports = (Class) => (...args) => {
  const ambientControllers = Controller.internals.retrieveParentControllers();
  const instance = new Class(...args);
  const initialExports = instance.exports;
  Controller.internals.setParentController(ambientControllers.at(-1));
  const internals = instance.component.manager.internals;
  internals.markExports(instance, initialExports);
  instance.watchExports((exports) => internals.markExports(instance, exports));
  Controller.internals.setAmbientChildController(instance);
  const hostCandidates = [instance.component, ...ambientControllers].reverse();
  return internals.trackKey(
    hostCandidates,
    (resolution) => resolution === void 0 ? void 0 : setProxy(instance, resolution.host, resolution.key, initialExports),
    initialExports
  );
};
function setProxy(controller, host, key, initialExports) {
  const genericHost = host;
  const controllerValueChanged = genericHost[key] !== controller.exports;
  const hostValueChanged = genericHost[key] !== initialExports;
  const controllerUpdatedExports = initialExports !== controller.exports;
  if (controllerValueChanged && !hostValueChanged && controllerUpdatedExports)
    genericHost[key] = controller.exports;
  controller.watchExports(() => {
    if (genericHost[key] === controller.exports)
      return;
    const manager = controller.component.manager;
    const isReadOnly = manager.internals.readonlyProps?.has(key) === true;
    if (isReadOnly)
      manager.bypassReadonly(() => {
        genericHost[key] = controller.exports;
      });
    else
      genericHost[key] = controller.exports;
  });
}

// src/functional.ts
var makeController = (constructor) => proxy(void 0, constructor);
var FunctionalController = class extends Controller {
  constructor(component, constructor) {
    super(component);
    const originalExports = this.exports;
    try {
      Controller.internals.setAmbientComponent(this.component);
      const value = constructor(this.component, this);
      const constructorChangedExports = this.exports !== originalExports;
      if (value instanceof Promise) {
        if (!constructorChangedExports)
          this.setProvisionalExports(value);
        const resolved = value.then((result) => {
          this.exports = result;
          super.catchUpLifecycle();
        }).catch((error) => {
          this._ready.reject(error);
          console.error(error);
        });
        this.onLoad(async () => await resolved);
      } else {
        if (!constructorChangedExports || value !== void 0)
          this.exports = value;
        queueMicrotask(() => super.catchUpLifecycle());
      }
    } catch (error) {
      this._ready.reject(error);
      console.error(error);
    }
  }
  /** Noop - will be called in the constructor instead */
  catchUpLifecycle() {
    return;
  }
};
var proxy = proxyExports(FunctionalController);

// src/load.ts
var load = (loader) => makeController(loader);
var AccessorController = class extends GenericController {
  constructor(component, _loadAccessor) {
    super(component);
    this._loadAccessor = _loadAccessor;
    this.reactiveUtils = this.component.reactiveUtils;
    this._watchedProperties = /* @__PURE__ */ new Set();
    this.setProvisionalExports(accessorInternals.makeGetterProxy(component, this._watchedProperties));
    this._originalReactiveUtilsIntegration = this.component.manager.internals.reactiveUtilsIntegration;
    this.component.manager.internals.reactiveUtilsIntegration = this.hostLoad.bind(this);
  }
  async hostLoad() {
    this._loadingPromise ?? (this._loadingPromise = safeAsyncCall(this._load.bind(this)));
    await this._loadingPromise;
  }
  async _load() {
    if (this.component.reactiveUtils === void 0)
      this.reactiveUtils = await (0,_index_0bc55ca5_js__WEBPACK_IMPORTED_MODULE_1__.i)();
    else
      this.reactiveUtils = await this.use(this.component.reactiveUtils);
    const parameters = accessorInternals.gatherParameters(this, this._watchedProperties);
    this._instance = await this._createInstance(parameters);
    const members = getPropLikeMembers(this.component);
    const unwatchedMembers = members.filter((member) => !this._watchedProperties.has(member));
    if (unwatchedMembers.length > 0)
      await this._originalReactiveUtilsIntegration(unwatchedMembers);
    accessorInternals.watchComponentUpdates(this, this._instance, this._watchedProperties);
    accessorInternals.watchAccessorUpdates(this, this._instance, this._watchedProperties);
    this.exports = this._instance;
  }
  async _createInstance(parameters) {
    if (this._isAccessorConstructor(this._loadAccessor))
      return new this._loadAccessor(parameters);
    else
      return await this._loadAccessor(parameters);
  }
  _isAccessorConstructor(loader) {
    return "prototype" in loader && "declaredClass" in loader.prototype;
  }
};
var accessorInternals = {
  makeGetterProxy: (component, watchedProperties) => new Proxy(
    {},
    {
      /*
       * Without this, makeProvisionalValue() will throw on accessing
       * non-existent prop
       */
      has: (target, prop) => typeof prop === "string" || prop in target,
      get: (target, prop) => {
        const value = Reflect.get(target, prop);
        if (typeof prop === "symbol" || prop in Promise.prototype)
          return value;
        if (prop in target)
          return value;
        watchedProperties.add(prop);
        return value;
      }
    }
  ),
  // Update Accessor on component prop change
  watchComponentUpdates(controller, instance, watchedProperties) {
    const readonlyProps = findReadOnlyAccessorProps(instance);
    const getter = (_value, propertyName) => instance[propertyName];
    const setter = (newValue, _oldValue, propertyName) => {
      if (instance[propertyName] === newValue)
        return newValue;
      instance[propertyName] = newValue;
      return instance[propertyName];
    };
    const { component } = controller;
    watchedProperties.forEach((propertyName) => {
      if (!readonlyProps.has(propertyName))
        component[propertyName] = component[propertyName] || instance[propertyName];
      controller.internals.accessorGetter[propertyName] = getter;
      controller.internals.accessorSetter[propertyName] = setter;
    });
  },
  // Update component on Accessor prop change
  watchAccessorUpdates(controller, instance, watchedProperties) {
    const { component } = controller;
    component.manager.bypassGetter(
      () => watchedProperties.forEach((property) => {
        const domValue = component[property];
        const modelValue = instance[property];
        if (domValue != null && modelValue !== domValue)
          instance[property] = domValue;
      })
    );
    controller.onLifecycle(
      () => Array.from(
        watchedProperties,
        (aliasName) => controller.reactiveUtils.watch(
          () => instance[aliasName],
          () => watchCallback(component, instance, aliasName),
          { initial: true }
        )
      )
    );
  },
  gatherParameters(controller, watchedProperties) {
    const { component } = controller;
    const data = Object.fromEntries(
      Array.from(watchedProperties, (key) => [key, component[key]]).filter(
        ([, value]) => value !== void 0
      )
    );
    return data ;
  }
};
function findReadOnlyAccessorProps(instance) {
  const accessor = instance;
  const properties = Object.entries(accessor.__accessor__?.metadata ?? {});
  return new Set(
    properties.filter(([_property, descriptor]) => descriptor?.readOnly === true).map(([property]) => property)
  );
}
function watchCallback(component, instance, property) {
  const newValue = instance[property];
  component[property] = newValue;
}
function useT9n({
  blocking = false,
  name
} = {}) {
  return makeController((component, controller) => {
    controller.onLifecycle(
      () => startLocaleObserver(
        component.el,
        (0,_index_6e172aac_js__WEBPACK_IMPORTED_MODULE_0__.a)("./assets"),
        ({ t9nLocale, t9nStrings, lang }) => {
          controller.exports = { ...t9nStrings, _lang: lang, _t9nLocale: t9nLocale };
          const label = t9nStrings.componentLabel ?? t9nStrings.widgetLabel;
          if (typeof label === "string" && "label" in component && component.label == null)
            component.label ?? (component.label = label);
        },
        name
      )
    );
    if (blocking)
      return controller.ready;
    const locale = getElementLocales(component.el);
    return { _lang: locale.lang, _t9nLocale: locale.t9nLocale };
  });
}

// src/usePropertyChange.ts
var usePropertyChange = (_component) => propertyChangeController;
var eventName = "arcgisPropertyChange";
var propertyChangeController = (...toWatch) => makeController((component, controller) => {
  const eventEmitter = component[eventName];
  controller.onLoad(
    () => controller.onLifecycle(
      () => toWatch.map(
        (name) => (
          // Casting to 'el' to simplify dynamic prop name typing
          component.manager.watch(name, () => eventEmitter.emit({ name }))
        )
      )
    )
  );
  return eventEmitter;
});




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvdmVuZG9ycy1ub2RlX21vZHVsZXNfYXJjZ2lzX21hcC1jb21wb25lbnRzX2Rpc3RfZXNtX2NodW5rLVdRVENVWEJTLTllYzM3ODFhX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMEU7QUFDNEQ7O0FBRXRJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxLQUFLO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXLEdBQUcsT0FBTztBQUN2QyxzQkFBc0IsS0FBSyxFQUFFLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixLQUFLLEVBQUUsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QiwyQkFBMkIsV0FBVyxHQUFHLFVBQVU7QUFDbkQsb0JBQW9CLFVBQVU7QUFDOUI7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxJQUFJO0FBQ3ZFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csb0JBQW9CO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixvQkFBb0I7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsU0FBUztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQiwwQ0FBMEMsaUJBQWlCO0FBQ3BIO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0NBQXNDLGdCQUFnQiwwQ0FBMEMsaUJBQWlCO0FBQ2pIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCw0Q0FBNEMsRUFBRTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSkFBb0o7QUFDcEo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsV0FBVztBQUMxRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUtBQXVLLEtBQUssT0FBTyxxQkFBcUI7QUFDeE07QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsS0FBSyxvQkFBb0Isc0JBQXNCO0FBQzFGLFlBQVkscUNBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFEQUFrQixJQUFJLHFEQUFtQztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCwyQkFBMkIscURBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFEQUFXO0FBQ25CO0FBQ0EsZ0RBQWdELFNBQVMsT0FBTyx3Q0FBd0Msc0JBQXNCO0FBQzlIO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkJBQTJCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxRQUFRO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SUFBdUksUUFBUTtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFEQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFEQUFZO0FBQ3BCLFdBQVcsNkJBQTZCO0FBQ3hDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxNQUFNO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUV3SiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9tYXAtY29tcG9uZW50cy9kaXN0L2VzbS9jaHVuay1XUVRDVVhCUy05ZWMzNzgxYS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRXNyaSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9qcy5hcmNnaXMuY29tLzQuMzAvZXNyaS9jb3B5cmlnaHQudHh0IGZvciBkZXRhaWxzLlxuICogdjQuMzAuMC1uZXh0LjM3XG4gKi9cbmltcG9ydCB7IGEgYXMgZ2V0QXNzZXRQYXRoLCBmIGFzIGZvcmNlVXBkYXRlIH0gZnJvbSAnLi9pbmRleC02ZTE3MmFhYy5qcyc7XG5pbXBvcnQgeyBsIGFzIGltcG9ydENvcmVBY2Nlc3NvciwgbSBhcyBpbXBvcnRDb3JlQWNjZXNzb3JTdXBwb3J0RGVjb3JhdG9ycywgaSBhcyBpbXBvcnRDb3JlUmVhY3RpdmVVdGlscyB9IGZyb20gJy4vaW5kZXgtMGJjNTVjYTUuanMnO1xuXG4vLyBzcmMvc3RlbmNpbC50c1xuZnVuY3Rpb24gcmV0cmlldmVDb21wb25lbnRNZXRhKGNvbXBvbmVudCkge1xuICBjb25zdCBjb25zdHJ1Y3RvciA9IGNvbXBvbmVudC5jb25zdHJ1Y3RvcjtcbiAgY29uc3QgbWVtYmVycyA9IGNvbnN0cnVjdG9yLl9fcmVnaXN0ZXJDb250cm9sbGVycz8uKGNvbXBvbmVudCkgPz8gdm9pZCAwO1xuICBjb25zdHJ1Y3Rvci5fX3JlZ2lzdGVyQ29udHJvbGxlcnMgPSB2b2lkIDA7XG4gIGlmICh0eXBlb2YgbWVtYmVycyAhPT0gXCJvYmplY3RcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkZhaWxlZCB0byByZXRyaWV2ZSBpbnRlcm5hbCBjb21wb25lbnQgbWV0YS4gTWFrZSBzdXJlIHlvdSBoYXZlIHRoZSB1c2VDb21wb25lbnRzQ29udHJvbGxlcnMoKSBSb2xsdXAgUGx1Z2luIGZvciBTdGVuY2lsIENvbnRyb2xsZXJzIGNvbmZpZ3VyZWQgaW4geW91ciBTdGVuY2lsIGNvbmZpZy5cIlxuICAgICk7XG4gIGNvbXBvbmVudC5tYW5hZ2VyLmludGVybmFscy5tZW1iZXJzID0gbWVtYmVycztcbn1cbmZ1bmN0aW9uIHBhcnNlUHJvcGVydHlWYWx1ZSh2YWx1ZSwgdHlwZSA9IDggLyogQW55ICovKSB7XG4gIGNvbnN0IGlzQ29tcGxleCA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xuICBpZiAoaXNDb21wbGV4KVxuICAgIHJldHVybiB2YWx1ZTtcbiAgaWYgKCh0eXBlICYgNCAvKiBCb29sZWFuICovKSAhPT0gMClcbiAgICByZXR1cm4gdmFsdWUgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDogdmFsdWUgPT09IFwiXCIgfHwgISF2YWx1ZTtcbiAgZWxzZSBpZiAoKHR5cGUgJiAyIC8qIE51bWJlciAqLykgIT09IDApXG4gICAgcmV0dXJuIE51bWJlci5wYXJzZUZsb2F0KHZhbHVlLnRvU3RyaW5nKCkpO1xuICBlbHNlIGlmICgodHlwZSAmIDEgLyogU3RyaW5nICovKSAhPT0gMClcbiAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgZWxzZVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbnZhciBtYWtlTWVtYmVyRmlsdGVyID0gKGZpbHRlcikgPT4gKGNvbXBvbmVudCkgPT4ge1xuICBjb25zdCBtZW1iZXJzID0gY29tcG9uZW50Lm1hbmFnZXIuaW50ZXJuYWxzLm1lbWJlcnM7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhtZW1iZXJzID8/IHt9KS5maWx0ZXIoKFtfbmFtZSwgW3Byb3BUeXBlXV0pID0+IChwcm9wVHlwZSAmIGZpbHRlcikgIT09IDApLm1hcCgoW25hbWVdKSA9PiBuYW1lKTtcbn07XG52YXIgZ2V0UHJvcExpa2VNZW1iZXJzID0gbWFrZU1lbWJlckZpbHRlcig2MyAvKiBQcm9wTGlrZSAqLyk7XG52YXIgZ2V0TWVtYmVyVHlwZSA9IChjb21wb25lbnQsIG5hbWUpID0+IGNvbXBvbmVudC5tYW5hZ2VyLmludGVybmFscy5tZW1iZXJzPy5bbmFtZV0/LlswXTtcbmZ1bmN0aW9uIGdldFByb3BUeXBlKGNvbXBvbmVudCwgbmFtZSkge1xuICBjb25zdCB0eXBlID0gZ2V0TWVtYmVyVHlwZShjb21wb25lbnQsIG5hbWUpO1xuICBpZiAodHlwZSA9PT0gdm9pZCAwKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGVsc2UgaWYgKHR5cGUgJiAzMiAvKiBTdGF0ZSAqLylcbiAgICByZXR1cm4gXCJzdGF0ZVwiO1xuICBlbHNlXG4gICAgcmV0dXJuIFwicHJvcFwiO1xufVxuXG4vLyAuLi9jb21wb25lbnRzLXV0aWxzL2Rpc3QvaW5kZXguanNcbnZhciBEZWZlcnJlZCA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgZGVmZXJyZWQgcHJvbWlzZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucmVzb2x2ZSA9ICgpID0+IHZvaWQgMDtcbiAgICB0aGlzLnJlamVjdCA9ICgpID0+IHZvaWQgMDtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBpblRhcmdldEVsZW1lbnQoZWxlbWVudCwgdGFyZ2V0RWxlbWVudCkge1xuICBsZXQgY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICB3aGlsZSAoY3VycmVudEVsZW1lbnQpIHtcbiAgICBpZiAoY3VycmVudEVsZW1lbnQgPT09IHRhcmdldEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWN1cnJlbnRFbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRFbGVtZW50LnBhcmVudE5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICBjdXJyZW50RWxlbWVudCA9IGN1cnJlbnRFbGVtZW50LnBhcmVudE5vZGUuaG9zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudEVsZW1lbnQgPSBjdXJyZW50RWxlbWVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBvYnNlcnZlQW5jZXN0b3JzTXV0YXRpb24oZWxlbWVudCwgYXR0cmlidXRlRmlsdGVyLCBjYWxsYmFjaykge1xuICBjb25zdCB7IHN1YnNjcmliZSB9ID0gb2JzZXJ2ZShhdHRyaWJ1dGVGaWx0ZXIpO1xuICByZXR1cm4gc3Vic2NyaWJlKChtdXRhdGlvbnMpID0+IHtcbiAgICBjb25zdCBtYXRjaGVkID0gbXV0YXRpb25zLnNvbWUoKG11dGF0aW9uKSA9PiBpblRhcmdldEVsZW1lbnQoZWxlbWVudCwgbXV0YXRpb24udGFyZ2V0KSk7XG4gICAgaWYgKG1hdGNoZWQpXG4gICAgICBjYWxsYmFjaygpO1xuICB9KTtcbn1cbnZhciBvYnNlcnZlcnMgPSB7fTtcbmZ1bmN0aW9uIG9ic2VydmUoYXR0cmlidXRlRmlsdGVyKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVGaWx0ZXIuam9pbihcIixcIik7XG4gIGNvbnN0IHByZXZpb3VzT2JzZXJ2ZXIgPSBvYnNlcnZlcnNbYXR0cmlidXRlc107XG4gIGlmIChwcmV2aW91c09ic2VydmVyICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIHByZXZpb3VzT2JzZXJ2ZXI7XG4gIGNvbnN0IHN1YnNjcmliZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgbXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMpID0+IHN1YnNjcmliZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhtdXRhdGlvbnMpKSk7XG4gIG11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHtcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGF0dHJpYnV0ZUZpbHRlcixcbiAgICBzdWJ0cmVlOiB0cnVlXG4gIH0pO1xuICBjb25zdCBvYnNlcnZlciA9IHtcbiAgICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgIHN1YnNjcmliZXJzLmFkZChjYWxsYmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6ICgpID0+IHtcbiAgICAgICAgICBzdWJzY3JpYmVycy5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgICAgIGlmIChzdWJzY3JpYmVycy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIG9ic2VydmVyc1thdHRyaWJ1dGVzXSA9IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBvYnNlcnZlcnNbYXR0cmlidXRlc10gPSBvYnNlcnZlcjtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuZnVuY3Rpb24gY2xvc2VzdEVsZW1lbnQoYmFzZSwgc2VsZWN0b3IpIHtcbiAgbGV0IGN1cnJlbnRFbGVtZW50ID0gYmFzZTtcbiAgd2hpbGUgKGN1cnJlbnRFbGVtZW50KSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGN1cnJlbnRFbGVtZW50LmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBjdXJyZW50RWxlbWVudC5nZXRSb290Tm9kZSgpO1xuICAgIGlmIChyb290RWxlbWVudCA9PT0gZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjdXJyZW50RWxlbWVudCA9IHJvb3RFbGVtZW50Lmhvc3Q7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50QXR0cmlidXRlKGVsLCBwcm9wLCBmYWxsYmFja1ZhbHVlKSB7XG4gIGNvbnN0IGNsb3Nlc3QgPSBjbG9zZXN0RWxlbWVudChlbCwgYFske3Byb3B9XWApO1xuICByZXR1cm4gY2xvc2VzdD8uZ2V0QXR0cmlidXRlKHByb3ApID8/IGZhbGxiYWNrVmFsdWU7XG59XG5mdW5jdGlvbiBzYWZlQ2FsbChjYWxsYmFjaykge1xuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjaz8uKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvciwgY2FsbGJhY2spO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5hc3luYyBmdW5jdGlvbiBzYWZlQXN5bmNDYWxsKGNhbGxiYWNrKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGNhbGxiYWNrKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvciwgY2FsbGJhY2spO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG52YXIgY2FwaXRhbGl6ZSA9IChzdHJpbmcpID0+IHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbnZhciBjYW1lbFRvSHVtYW4gPSAodmFsdWUpID0+IGNhcGl0YWxpemUodmFsdWUucmVwbGFjZUFsbCgvKFthLXpdKShbQS1aXSkvZ3UsIFwiJDEgJDJcIikpO1xudmFyIHN1cHBvcnRlZExvY2FsZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiYXJcIixcbiAgXCJiZ1wiLFxuICBcImJzXCIsXG4gIFwiY2FcIixcbiAgXCJjc1wiLFxuICBcImRhXCIsXG4gIFwiZGVcIixcbiAgXCJlbFwiLFxuICBcImVuXCIsXG4gIFwiZXNcIixcbiAgXCJldFwiLFxuICBcImZpXCIsXG4gIFwiZnJcIixcbiAgXCJoZVwiLFxuICBcImhyXCIsXG4gIFwiaHVcIixcbiAgXCJpZFwiLFxuICBcIml0XCIsXG4gIFwiamFcIixcbiAgXCJrb1wiLFxuICBcImx0XCIsXG4gIFwibHZcIixcbiAgXCJubFwiLFxuICBcIm5iXCIsXG4gIFwicGxcIixcbiAgXCJwdC1CUlwiLFxuICBcInB0LVBUXCIsXG4gIFwicm9cIixcbiAgXCJydVwiLFxuICBcInNrXCIsXG4gIFwic2xcIixcbiAgXCJzclwiLFxuICBcInN2XCIsXG4gIFwidGhcIixcbiAgXCJ0clwiLFxuICBcInVrXCIsXG4gIFwidmlcIixcbiAgXCJ6aC1DTlwiLFxuICBcInpoLUhLXCIsXG4gIFwiemgtVFdcIlxuXSk7XG52YXIgZGVmYXVsdExvY2FsZSA9IFwiZW5cIjtcbmFzeW5jIGZ1bmN0aW9uIGZldGNoVDlOU3RyaW5nc0J1bmRsZShsb2NhbGUsIGFzc2V0c1BhdGgsIHByZWZpeCA9IFwiXCIpIHtcbiAgY29uc3QgcGF0aCA9IGAke2Fzc2V0c1BhdGh9LyR7cHJlZml4fWA7XG4gIGNvbnN0IGZpbGVQYXRoID0gYCR7cGF0aH0ke2xvY2FsZX0uanNvbmA7XG4gIHQ5blN0cmluZ3NDYWNoZVtmaWxlUGF0aF0gPz8gKHQ5blN0cmluZ3NDYWNoZVtmaWxlUGF0aF0gPSBmZXRjaEJ1bmRsZShsb2NhbGUsIHBhdGgpKTtcbiAgcmV0dXJuIGF3YWl0IHQ5blN0cmluZ3NDYWNoZVtmaWxlUGF0aF07XG59XG52YXIgdDluU3RyaW5nc0NhY2hlID0ge307XG5hc3luYyBmdW5jdGlvbiBmZXRjaEJ1bmRsZShsb2NhbGUsIHBhdGgpIHtcbiAgY29uc3QgZmlsZVBhdGggPSBgJHtwYXRofSR7bG9jYWxlfS5qc29uYDtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGZpbGVQYXRoKTtcbiAgICBpZiAocmVzcG9uc2Uub2spXG4gICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiBmYWxsYmFja0J1bmRsZTtcbiAgfVxuICBpZiAobG9jYWxlID09PSBkZWZhdWx0TG9jYWxlKVxuICAgIHJldHVybiBmYWxsYmFja0J1bmRsZTtcbiAgcmV0dXJuIGF3YWl0IGZldGNoQnVuZGxlKGRlZmF1bHRMb2NhbGUsIHBhdGgpO1xufVxudmFyIGZhbGxiYWNrQnVuZGxlID0gbmV3IFByb3h5KFxuICB7fSxcbiAge1xuICAgIGdldDogKF90YXJnZXQsIHByb3BlcnR5KSA9PiBjYW1lbFRvSHVtYW4ocHJvcGVydHkudG9TdHJpbmcoKSlcbiAgfVxuKTtcbmZ1bmN0aW9uIGdldEVsZW1lbnRMb2NhbGVzKGVsZW1lbnQpIHtcbiAgY29uc3QgbGFuZyA9IGdldEVsZW1lbnRBdHRyaWJ1dGUoZWxlbWVudCwgXCJsYW5nXCIsIG5hdmlnYXRvci5sYW5ndWFnZSB8fCBkZWZhdWx0TG9jYWxlKTtcbiAgaWYgKHN1cHBvcnRlZExvY2FsZXMuaGFzKGxhbmcpKSB7XG4gICAgcmV0dXJuIHsgbGFuZywgdDluTG9jYWxlOiBsYW5nIH07XG4gIH1cbiAgY29uc3Qgcm9vdENvZGUgPSBsYW5nLnNsaWNlKDAsIDIpO1xuICByZXR1cm4geyBsYW5nLCB0OW5Mb2NhbGU6IHN1cHBvcnRlZExvY2FsZXMuaGFzKHJvb3RDb2RlKSA/IHJvb3RDb2RlIDogZGVmYXVsdExvY2FsZSB9O1xufVxuZnVuY3Rpb24gc3RhcnRMb2NhbGVPYnNlcnZlcihlbGVtZW50LCBhc3NldHNQYXRoLCBvblVwZGF0ZWQsIGFzc2V0TmFtZSkge1xuICBsZXQgcmVzdWx0ID0gdm9pZCAwO1xuICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHZvaWQgdXBkYXRlQ29tcG9uZW50TG9jYXRlU3RhdGUoZWxlbWVudCwgYXNzZXRzUGF0aCwgYXNzZXROYW1lKS50aGVuKChuZXdSZXN1bHQpID0+IHtcbiAgICBpZiAocmVzdWx0Py5sYW5nICE9PSBuZXdSZXN1bHQubGFuZyB8fCByZXN1bHQudDluTG9jYWxlICE9PSBuZXdSZXN1bHQudDluTG9jYWxlIHx8IHJlc3VsdC50OW5TdHJpbmdzICE9PSBuZXdSZXN1bHQudDluU3RyaW5ncylcbiAgICAgIG9uVXBkYXRlZChuZXdSZXN1bHQpO1xuICAgIHJlc3VsdCA9IG5ld1Jlc3VsdDtcbiAgfSkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gIGNhbGxiYWNrKCk7XG4gIHJldHVybiBvYnNlcnZlQW5jZXN0b3JzTXV0YXRpb24oZWxlbWVudCwgW1wibGFuZ1wiXSwgY2FsbGJhY2spO1xufVxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TG9jYXRlU3RhdGUoZWxlbWVudCwgYXNzZXRzUGF0aCwgYXNzZXROYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZShcImFyY2dpcy1cIiwgXCJcIikpIHtcbiAgY29uc3QgeyBsYW5nLCB0OW5Mb2NhbGUgfSA9IGdldEVsZW1lbnRMb2NhbGVzKGVsZW1lbnQpO1xuICBjb25zdCB0OW5Bc3NldHNQYXRoID0gYCR7YXNzZXRzUGF0aH0vJHthc3NldE5hbWV9L3Q5bmA7XG4gIGNvbnN0IHByZWZpeCA9IGAke2Fzc2V0TmFtZX0udDluLmA7XG4gIGNvbnN0IHQ5blN0cmluZ3MgPSBhd2FpdCBmZXRjaFQ5TlN0cmluZ3NCdW5kbGUodDluTG9jYWxlLCB0OW5Bc3NldHNQYXRoLCBwcmVmaXgpO1xuICByZXR1cm4geyBsYW5nLCB0OW5Mb2NhbGUsIHQ5blN0cmluZ3MgfTtcbn1cblxuLy8gc3JjL3R5cGVzLnRzXG52YXIgY29udHJvbGxlclN5bWJvbCA9IFN5bWJvbChcImNvbnRyb2xsZXJcIik7XG5cbi8vIHNyYy91dGlscy50c1xuZnVuY3Rpb24gZXh0ZW5kT2JqZWN0KGJhc2UsIGV4dGVuZCkge1xuICBPYmplY3QuZW50cmllcyhleHRlbmQpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChrZXkgaW4gYmFzZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGV4dGVuZCBvYmplY3QgYmVjYXVzZSBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZGApO1xuICAgIGNvbnN0IHRoaXNCYXNlID0gYmFzZTtcbiAgICB0aGlzQmFzZVtrZXldID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gYmFzZTtcbn1cbnZhciBpc0NvbnRyb2xsZXIgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAoY29udHJvbGxlclN5bWJvbCBpbiB2YWx1ZSB8fCBcImhvc3RDb25uZWN0ZWRcIiBpbiB2YWx1ZSB8fCBcImhvc3REaXNjb25uZWN0ZWRcIiBpbiB2YWx1ZSB8fCBcImhvc3RVcGRhdGVcIiBpbiB2YWx1ZSB8fCBcImhvc3RVcGRhdGVkXCIgaW4gdmFsdWUpO1xuXG4vLyBzcmMvQ29udHJvbGxlckludGVybmFscy50c1xudmFyIENvbnRyb2xsZXJJbnRlcm5hbHMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2FtYmllbnRDb250cm9sbGVycyA9IFtdO1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIGRlZmluaXRpb24gaGFzIHRvIGJlIGR1cGxpY2F0ZWQgZHVlIHRvIHRoZVxuICAgICAqIFwiJ3VzZScgaXMgcmVmZXJlbmNlZCBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluIGl0cyBvd24gdHlwZSBhbm5vdGF0aW9uLlwiXG4gICAgICogZXJyb3JcbiAgICAgKi9cbiAgICB0aGlzLnVzZSA9IGFzeW5jICh2YWx1ZSwgd2F0Y2hFeHBvcnRzKSA9PiB7XG4gICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy5fdXNlUmVmU3luYyh2YWx1ZSk7XG4gICAgICBpZiAoY29udHJvbGxlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2F0Y2hFeHBvcnRzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBVbmFibGUgdG8gcmVzb2x2ZSBhIGNvbnRyb2xsZXIgZnJvbSB0aGUgcHJvdmlkZWQgdmFsdWUsIHNvIGNhbid0IHdhdGNoIGl0J3MgZXhwb3J0cy4gJHt1bnJlc29sdmFibGVFeHBvcnRzfWBcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IGNvbnRyb2xsZXIucmVhZHk7XG4gICAgICBpZiAodHlwZW9mIHdhdGNoRXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmIChjb250cm9sbGVyLndhdGNoRXhwb3J0cyA9PT0gdm9pZCAwKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGNvbnRyb2xsZXIgbXVzdCBpbXBsZW1lbnQgd2F0Y2hFeHBvcnRzIG1ldGhvZCB0byBzdXBwb3J0IHdhdGNoaW5nIGV4cG9ydHNgKTtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBjb250cm9sbGVyLndhdGNoRXhwb3J0cyhcbiAgICAgICAgICAoZXhwb3J0cykgPT4gd2F0Y2hFeHBvcnRzKGV4cG9ydHMsIHVuc3Vic2NyaWJlKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZXhwb3J0cztcbiAgICB9O1xuICAgIHRoaXMudXNlUmVmID0gYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy5fdXNlUmVmU3luYyh2YWx1ZSk7XG4gICAgICBpZiAoY29udHJvbGxlciA9PT0gdm9pZCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byByZXNvbHZlIGEgY29udHJvbGxlciBmcm9tIHRoZSBwcm92aWRlZCB2YWx1ZS4gJHt1bnJlc29sdmFibGVFeHBvcnRzfWApO1xuICAgICAgYXdhaXQgY29udHJvbGxlci5yZWFkeTtcbiAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH07XG4gICAgdGhpcy5zaG91bGRCeXBhc3NTZXR0ZXIgPSBmYWxzZTtcbiAgICB0aGlzLnNob3VsZEJ5cGFzc0dldHRlciA9IGZhbHNlO1xuICAgIHRoaXMuc2hvdWxkQnlwYXNzUmVhZG9ubHkgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBBIG1hcCBmcm9tIGNvbXBvbmVudCBpbnN0YW5jZSBvciBjb21wb25lbnQgZWxlbWVudCB0byBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAgICogVG8gZ2V0IGZyb20gY29tcG9uZW50IGluc3RhbmNlIG9yIGNvbXBvbmVudCBlbGVtZW50IHRvIGNvbXBvbmVudCBlbGVtZW50LFxuICAgICAqIHlvdSBjYW4ganVzdCB1c2UgdGhlIC5lbCBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudFRvSW5zdGFuY2UgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgfVxuICAvKlxuICAgKiBBbGxvdyBjb250cm9sbGVycyB0byBpbXBsaWNpdGx5IHJldHJpZXZlIHdoaWNoIGNvbXBvbmVudCB0aGV5IGFyZSBpbiwgdG9cbiAgICogaW1wcm92ZSBEWCAoYXZvaWRzIHRoZSBuZWVkIHRvIHBhc3MgXCJ0aGlzXCIgZXhwbGljaXRseSBmb3IgZWFjaCBjb250cm9sbGVyKVxuICAgKi9cbiAgc2V0QW1iaWVudENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICBpZiAodGhpcy5fYW1iaWVudENvbXBvbmVudCA9PT0gY29tcG9uZW50KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2FtYmllbnRDb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2FtYmllbnRDb21wb25lbnQgPT09IGNvbXBvbmVudClcbiAgICAgICAgdGhpcy5fYW1iaWVudENvbXBvbmVudCA9IHZvaWQgMDtcbiAgICB9KTtcbiAgfVxuICByZXRyaWV2ZUNvbXBvbmVudChuYW1lKSB7XG4gICAgaWYgKHRoaXMuX2FtYmllbnRDb21wb25lbnQgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgW1xuICAgICAgICAgIGBVbmFibGUgdG8gZmluZCBvdXQgd2hpY2ggY29tcG9uZW50ICR7bmFtZSB8fCBcInRoaXNcIn0gY29udHJvbGxlciBgLFxuICAgICAgICAgIFwiYmVsb25ncyB0by4gVGhpcyBtaWdodCBoYXBwZW4gaWYgeW91IHRyaWVkIHRvIGNyZWF0ZSBhIGNvbnRyb2xsZXIgXCIsXG4gICAgICAgICAgXCJvdXRzaWRlIHRoZSBjb21wb25lbnQuIElmIHNvLCBwbGVhc2Ugd3JhcCB5b3VyIGNvbnRyb2xsZXIgXCIsXG4gICAgICAgICAgXCJkZWZpbml0aW9uIGluIGFuIGFycm93IGZ1bmN0aW9uLCBcIixcbiAgICAgICAgICBcImBjb25zdCBteUNvbnRyb2xsZXIgPSAoKT0+bWFrZUNvbnRyb2xsZXIoLi4uKTtgIGFuZCBjYWxsIHRoYXRcIixcbiAgICAgICAgICBcImZ1bmN0aW9uIGluc2lkZSB0aGUgY29tcG9uZW50IGBteSA9IG15Q29udHJvbGxlcigpO2AsIG9yIFwiLFxuICAgICAgICAgIFwiZGVmaW5lIHlvdXIgY29udHJvbGxlciB1c2luZyBtYWtlR2VuZXJpY0NvbnRyb2xsZXIvR2VuZXJpY0NvbnRyb2xsZXIgXCIsXG4gICAgICAgICAgXCJpbnN0ZWFkLlxcblwiLFxuICAgICAgICAgIFwiSWYgeW91IHdpc2ggdG8gdXNlIGEgY29udHJvbGxlciBpbnNpZGUgYW4gYXN5bmMgY29udHJvbGxlciwgXCIsXG4gICAgICAgICAgXCJtYWtlIHN1cmUgeW91IGFyZSB1c2luZyBjb250cm9sbGVyLnVzZS5cXG5cIixcbiAgICAgICAgICBcIllvdSBtaWdodCBhbHNvIGhhdmUgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIENvbnRyb2xsZXJzIGxvYWRlZFwiXG4gICAgICAgIF0uam9pbihcIlxcblwiKVxuICAgICAgKTtcbiAgICByZXR1cm4gdGhpcy5fYW1iaWVudENvbXBvbmVudDtcbiAgfVxuICAvKlxuICAgKiBBaWRzIHByb3h5RXhwb3J0cygpIGluIGtub3dpbmcgd2hvIGlzIGl0J3MgaG9zdFxuICAgKi9cbiAgc2V0UGFyZW50Q29udHJvbGxlcihjb250cm9sbGVyKSB7XG4gICAgaWYgKGNvbnRyb2xsZXIgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fYW1iaWVudENvbnRyb2xsZXJzID0gW107XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fYW1iaWVudENvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlcik7XG4gICAgdGhpcy5fYW1iaWVudENvbnRyb2xsZXJzID0gaW5kZXggPT09IC0xID8gWy4uLnRoaXMuX2FtYmllbnRDb250cm9sbGVycywgY29udHJvbGxlcl0gOiB0aGlzLl9hbWJpZW50Q29udHJvbGxlcnMuc2xpY2UoMCwgaW5kZXggKyAxKTtcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICB0aGlzLl9hbWJpZW50Q29udHJvbGxlcnMgPSBbXTtcbiAgICB9KTtcbiAgfVxuICByZXRyaWV2ZVBhcmVudENvbnRyb2xsZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl9hbWJpZW50Q29udHJvbGxlcnM7XG4gIH1cbiAgLypcbiAgICogQWlkcyBjb250cm9sbGVyLnVzZSBpbiByZXRyaWV2aW5nIGNvbnRyb2xsZXIgdmFsdWUgd2hlbiBpdCByZWNlaXZlc1xuICAgKiBjb250cm9sbGVyIGV4cG9ydHMsIHJhdGhlciB0aGFuIHRoZSBjb250cm9sbGVyIGl0c2VsZlxuICAgKi9cbiAgc2V0QW1iaWVudENoaWxkQ29udHJvbGxlcihjb250cm9sbGVyKSB7XG4gICAgaWYgKHRoaXMuX2FtYmllbnRDaGlsZENvbnRyb2xsZXIgPT09IGNvbnRyb2xsZXIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fYW1iaWVudENoaWxkQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2FtYmllbnRDaGlsZENvbnRyb2xsZXIgPT09IGNvbnRyb2xsZXIpXG4gICAgICAgIHRoaXMuX2FtYmllbnRDaGlsZENvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgfSk7XG4gIH1cbiAgcmV0cmlldmVBbWJpZW50Q2hpbGRDb250cm9sbGVyKCkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzLl9hbWJpZW50Q2hpbGRDb250cm9sbGVyO1xuICAgIHRoaXMuX2FtYmllbnRDaGlsZENvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gIH1cbiAgLyoqXG4gICAqIFRyeSB0byByZXNvbHZlIGEgY29udHJvbGxlciwgd2l0aG91dCBhd2FpdGluZyBpdCdzIGxvYWRcbiAgICovXG4gIF91c2VSZWZTeW5jKHZhbHVlKSB7XG4gICAgY29uc3QgYW1iaWVudENoaWxkQ29udHJvbGxlciA9IHRoaXMucmV0cmlldmVBbWJpZW50Q2hpbGRDb250cm9sbGVyKCk7XG4gICAgaWYgKGFtYmllbnRDaGlsZENvbnRyb2xsZXIgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBhbWJpZW50Q2hpbGRDb250cm9sbGVyO1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IENvbnRyb2xsZXIuaW50ZXJuYWxzLnJldHJpZXZlQ29tcG9uZW50KCk7XG4gICAgY29uc3QgY29udHJvbGxlciA9IGNvbXBvbmVudC5tYW5hZ2VyLmludGVybmFscy5yZXNvbHZlRXhwb3J0cyh2YWx1ZSk7XG4gICAgaWYgKGNvbnRyb2xsZXIgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIGlmIChpc0NvbnRyb2xsZXIodmFsdWUpKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn07XG52YXIgdW5yZXNvbHZhYmxlRXhwb3J0cyA9IFtcbiAgXCJUaGUgdmFsdWUgeW91IHBhc3NlZCBpcyBub3QgYSBjb250cm9sbGVyIGFuZCBub3QgYSBjb250cm9sbGVyIGV4cG9ydHMuIElmIFwiLFxuICBcInlvdXIgY29udHJvbGxlciBleHBvcnRzIGEgbGl0ZXJhbCB2YWx1ZSwgdHJ5IG1ha2luZyB5b3VyIGNvbnRyb2xsZXIgZXhwb3J0IFwiLFxuICBcImFuIG9iamVjdCBpbnN0ZWFkXCJcbl0uam9pbihcIlwiKTtcblxuLy8gc3JjL0NvbnRyb2xsZXIudHNcbnZhciBfYTtcbnZhciBfQ29udHJvbGxlciA9IGNsYXNzIF9Db250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoY29tcG9uZW50KSB7XG4gICAgdGhpcy5fcmVhZHkgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICB0aGlzLl9saWZlY3ljbGVEaXNjb25uZWN0ZWQgPSBbXTtcbiAgICB0aGlzLmNvbm5lY3RlZENhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMud2lsbExvYWRDYWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRpZExvYWRDYWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzW19hXSA9IHRydWU7XG4gICAgdGhpcy5yZWFkeSA9IHRoaXMuX3JlYWR5LnByb21pc2U7XG4gICAgLypcbiAgICAgKiBTZXR0aW5nIGRlZmF1bHQgZXhwb3J0cyB0byBcInRoaXNcIiBzbyB0aGF0IGNvbnRyb2xsZXJzIHRoYXQgZG9uJ3QgdXNlXG4gICAgICogZXhwb3J0cy9wcm94eUV4cG9ydHMoKSwgY291bGQgc3RpbGwgYmUgdXNlZCBhcyBpZiB0aGV5IGRpZFxuICAgICAqIChpLmUgd2l0aCBjb250cm9sbGVyLnVzZSlcbiAgICAgKi9cbiAgICB0aGlzLl9leHBvcnRzID0gbWFrZVByb3Zpc2lvbmFsVmFsdWUodGhpcyk7XG4gICAgdGhpcy5fZXhwb3J0V2F0Y2hlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IHJlc29sdmVkQ29tcG9uZW50ID0gdG9Db250cm9sbGVySG9zdChcbiAgICAgIGNvbXBvbmVudCA/PyBfQ29udHJvbGxlci5pbnRlcm5hbHMucmV0cmlldmVDb21wb25lbnQobmV3LnRhcmdldC5uYW1lKVxuICAgICk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29tcG9uZW50XCIsIHtcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHJlc29sdmVkQ29tcG9uZW50XG4gICAgfSk7XG4gICAgdGhpcy5jb21wb25lbnQuYWRkQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBtYW5hZ2VyID0gdGhpcy5jb21wb25lbnQubWFuYWdlcjtcbiAgICB0aGlzLmNvbm5lY3RlZCA9IG1hbmFnZXI/LmNvbm5lY3RlZDtcbiAgICB0aGlzLmludGVybmFscyA9IG1hbmFnZXI/LmludGVybmFscztcbiAgICBfQ29udHJvbGxlci5pbnRlcm5hbHMuc2V0UGFyZW50Q29udHJvbGxlcih0aGlzKTtcbiAgICBpZiAoXCJob3N0RGVzdHJveVwiIGluIHRoaXMpXG4gICAgICB0aGlzLmNvbXBvbmVudC5tYW5hZ2VyLmVuc3VyZUhhc0Rlc3Ryb3koKTtcbiAgICBpZiAobWFuYWdlciAhPT0gdm9pZCAwKVxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gdGhpcy5jYXRjaFVwTGlmZWN5Y2xlKCkpO1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzO1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHtcbiAgICAgIGhvc3RDb25uZWN0ZWQ6IFwiaG9zdENvbm5lY3RlZFwiIGluIHRoaXMgPyBbKCkgPT4gY29udHJvbGxlci5ob3N0Q29ubmVjdGVkPy4oKV0gOiBbXSxcbiAgICAgIGhvc3REaXNjb25uZWN0ZWQ6IFwiaG9zdERpc2Nvbm5lY3RlZFwiIGluIHRoaXMgPyBbKCkgPT4gY29udHJvbGxlci5ob3N0RGlzY29ubmVjdGVkPy4oKV0gOiBbXSxcbiAgICAgIGhvc3RMb2FkOiBcImhvc3RMb2FkXCIgaW4gdGhpcyA/IFsoKSA9PiBjb250cm9sbGVyLmhvc3RMb2FkPy4oKV0gOiBbXSxcbiAgICAgIGhvc3RMb2FkZWQ6IFwiaG9zdExvYWRlZFwiIGluIHRoaXMgPyBbKCkgPT4gY29udHJvbGxlci5ob3N0TG9hZGVkPy4oKV0gOiBbXSxcbiAgICAgIGhvc3RSZW5kZXI6IFwiaG9zdFJlbmRlclwiIGluIHRoaXMgPyBbKCkgPT4gY29udHJvbGxlci5ob3N0UmVuZGVyPy4oKV0gOiBbXSxcbiAgICAgIGhvc3RSZW5kZXJlZDogXCJob3N0UmVuZGVyZWRcIiBpbiB0aGlzID8gWygpID0+IGNvbnRyb2xsZXIuaG9zdFJlbmRlcmVkPy4oKV0gOiBbXSxcbiAgICAgIGhvc3RVcGRhdGU6IFwiaG9zdFVwZGF0ZVwiIGluIHRoaXMgPyBbKCkgPT4gY29udHJvbGxlci5ob3N0VXBkYXRlPy4oKV0gOiBbXSxcbiAgICAgIGhvc3RVcGRhdGVkOiBcImhvc3RVcGRhdGVkXCIgaW4gdGhpcyA/IFsoKSA9PiBjb250cm9sbGVyLmhvc3RVcGRhdGVkPy4oKV0gOiBbXSxcbiAgICAgIGhvc3REZXN0cm95OiBcImhvc3REZXN0cm95XCIgaW4gdGhpcyA/IFsoKSA9PiBjb250cm9sbGVyLmhvc3REZXN0cm95Py4oKV0gOiBbXSxcbiAgICAgIGhvc3RMaWZlY3ljbGU6IFwiaG9zdExpZmVjeWNsZVwiIGluIHRoaXMgPyBbKCkgPT4gY29udHJvbGxlci5ob3N0TGlmZWN5Y2xlPy4oKV0gOiBbXVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIElmIGNvbnRyb2xsZXIgaXMgYmVpbmcgYWRkZWQgZHluYW1pY2FsbHksIGFmdGVyIHRoZSBjb21wb25lbnRcbiAgICogY29uc3RydWN0aW9uLCB0aGVuIHRyaWdnZXIgY29ubmVjdGVkIGFuZCBsb2FkIHJpZ2h0IGF3YXlcbiAgICovXG4gIGNhdGNoVXBMaWZlY3ljbGUoKSB7XG4gICAgaWYgKHRoaXMuY29ubmVjdGVkQ2FsbGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMudHJpZ2dlckNvbm5lY3RlZCgpO1xuICAgIGNvbnN0IGxvYWRXaWxsU3RpbGxIYXBwZW4gPSAhdGhpcy5jb21wb25lbnQubWFuYWdlci53aWxsTG9hZENhbGxlZDtcbiAgICBpZiAobG9hZFdpbGxTdGlsbEhhcHBlbilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnRyaWdnZXJMb2FkKCkudGhlbigoKSA9PiB7XG4gICAgICBjb25zdCBsb2FkZWRXaWxsU3RpbGxIYXBwZW4gPSAhdGhpcy5jb21wb25lbnQubWFuYWdlci5kaWRMb2FkQ2FsbGVkO1xuICAgICAgaWYgKGxvYWRlZFdpbGxTdGlsbEhhcHBlbilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy50cmlnZ2VyTG9hZGVkKCk7XG4gICAgfSkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gIH1cbiAgZ2V0IGV4cG9ydHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4cG9ydHM7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBjb250cm9sbGVyJ3MgZXhwb3J0cyBwcm9wZXJ0eSAoZm9yIHVzYWdlIHdpdGggcHJveHlFeHBvcnRzKCkpIGFuZCBtYXJrXG4gICAqIGNvbnRyb2xsZXIgYXMgcmVhZHkgKGZvciB1c2FnZSBpbiBvdGhlciBjb250cm9sbGVycykuIEFsc28sIHRyaWdnZXJzXG4gICAqIHJlLXJlbmRlciBvZiB0aGUgY29tcG9uZW50XG4gICAqL1xuICBzZXQgZXhwb3J0cyhleHBvcnRzKSB7XG4gICAgaWYgKHRoaXMuX2V4cG9ydHMgIT09IGV4cG9ydHMpIHtcbiAgICAgIHRoaXMuX2V4cG9ydHMgPSBleHBvcnRzO1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGVkQ2FsbGVkKVxuICAgICAgICB0aGlzLmNvbXBvbmVudC5yZXF1ZXN0VXBkYXRlKCk7XG4gICAgICB0aGlzLl9leHBvcnRXYXRjaGVycy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soZXhwb3J0cykpO1xuICAgIH1cbiAgICB0aGlzLl9yZWFkeS5yZXNvbHZlKGV4cG9ydHMpO1xuICB9XG4gIHNldFByb3Zpc2lvbmFsRXhwb3J0cyhleHBvcnRzKSB7XG4gICAgdGhpcy5fZXhwb3J0cyA9IG1ha2VQcm92aXNpb25hbFZhbHVlKGV4cG9ydHMpO1xuICAgIHRoaXMuX2V4cG9ydFdhdGNoZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayh0aGlzLl9leHBvcnRzKSk7XG4gIH1cbiAgd2F0Y2hFeHBvcnRzKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2FmZUNhbGxiYWNrID0gKGV4cG9ydHMpID0+IHNhZmVDYWxsKCgpID0+IGNhbGxiYWNrKGV4cG9ydHMpKTtcbiAgICB0aGlzLl9leHBvcnRXYXRjaGVycy5hZGQoc2FmZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4gdm9pZCB0aGlzLl9leHBvcnRXYXRjaGVycy5kZWxldGUoc2FmZUNhbGxiYWNrKTtcbiAgfVxuICAvKipcbiAgICogQSBmbGV4aWJsZSB1dGlsaXR5IGZvciBtYWtpbmcgc3VyZSBhIGNvbnRyb2xsZXIgaXMgbG9hZGVkIGJlZm9yZSBpdCdzIHVzZWQsXG4gICAqIHJlZ2FyZGxlc3Mgb2YgaG93IG9yIHdoZXJlIGEgY29udHJvbGxlciB3YXMgZGVmaW5lZDpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbWFrZUdlbmVyaWNDb250cm9sbGVyKGFzeW5jIChjb21wb25lbnQsIGNvbnRyb2xsZXIpID0+IHtcbiAgICogICAvLyBBd2FpdCBzb21lIGNvbnRyb2xsZXIgZnJvbSB0aGUgY29tcG9uZW50OlxuICAgKiAgIGF3YWl0IGNvbnRyb2xsZXIudXNlKGNvbXBvbmVudC5zb21lQ29udHJvbGxlcik7XG4gICAqICAgLy8gSW5pdGlhbGl6ZSBuZXcgY29udHJvbGxlcnNcbiAgICogICBhd2FpdCBjb250cm9sbGVyLnVzZShsb2FkKGltcG9ydENvcmVSZWFjdGl2ZVV0aWxzKSk7XG4gICAqICAgYXdhaXQgY29udHJvbGxlci51c2UobmV3IFZpZXdNb2RlbENvbnRyb2xsZXIoY29tcG9uZW50LG5ld1dpZGdldHNIb21lSG9tZVZpZXdNb2RlbCkpO1xuICAgKiAgIGF3YWl0IGNvbnRyb2xsZXIudXNlKHNvbWVDb250cm9sbGVyKGNvbXBvbmVudCkpO1xuICAgKiB9KTtcbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogSWYgeW91ciBjb250cm9sbGVyIGlzIG5vdCBhc3luYywgYW5kIHlvdSBhcmUgbm90IGNyZWF0aW5nIGl0IGFzeW5jLCB0aGVuXG4gICAqIHlvdSBhcmUgbm90IHJlcXVpcmVkIHRvIHVzZSBjb250cm9sbGVyLnVzZSAtIHlvdSBjYW4gdXNlIGl0IGRpcmVjdGx5LlxuICAgKiBTaW1pbGFybHksIGFjY2Vzc2luZyBjb250cm9sbGVycyBhZnRlciBjb21wb25lbnRXaWxsTG9hZCBjYWxsYmFjayBkb2VzIG5vdFxuICAgKiByZXF1aXJlIGF3YWl0aW5nIHRoZW0gYXMgdGhleSBhcmUgZ3VhcmFudGVlZCB0byBiZSBsb2FkZWQgYnkgdGhlbi5cbiAgICovXG4gIGdldCB1c2UoKSB7XG4gICAgX0NvbnRyb2xsZXIuaW50ZXJuYWxzLnNldEFtYmllbnRDb21wb25lbnQodGhpcy5jb21wb25lbnQpO1xuICAgIHJldHVybiBfQ29udHJvbGxlci5pbnRlcm5hbHMudXNlO1xuICB9XG4gIC8qKlxuICAgKiBKdXN0IGxpa2UgY29udHJvbGxlci51c2UsIGJ1dCByZXR1cm5zIHRoZSBjb250cm9sbGVyIGl0c2VsZiwgcmF0aGVyIHRoYW4gaXQnc1xuICAgKiBleHBvcnRzXG4gICAqXG4gICAqIFVzZSBjYXNlczpcbiAgICogLSBZb3UgaGF2ZSBhIGNvbnRyb2xsZXIgYW5kIHlvdSB3YW50IHRvIG1ha2Ugc3VyZSBpdCdzIGxvYWRlZCBiZWZvcmUgeW91XG4gICAqICAgdHJ5IHRvIHVzZSBpdFxuICAgKiAtIFlvdXIgY29udHJvbGxlciBpcyBub3QgdXNpbmcgZXhwb3J0cywgc28geW91IHdpc2ggdG8gYWNjZXNzIHNvbWUgcHJvcHMgb25cbiAgICogICBpdCBkaXJlY3RseVxuICAgKiAtIFlvdSBoYXZlIGEgY29udHJvbGxlciBleHBvcnRzIG9ubHksIGFuZCB5b3Ugd2FudCB0byByZXRyaWV2ZSB0aGVcbiAgICogICBjb250cm9sbGVyIGl0c2VsZi4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdpc2ggdG8gY2FsbCAud2F0Y2hFeHBvcnRzKCkgb3JcbiAgICogICBzb21lIG90aGVyIG1ldGhvZCBvbiB0aGUgY29udHJvbGxlclxuICAgKi9cbiAgZ2V0IHVzZVJlZigpIHtcbiAgICBfQ29udHJvbGxlci5pbnRlcm5hbHMuc2V0QW1iaWVudENvbXBvbmVudCh0aGlzLmNvbXBvbmVudCk7XG4gICAgcmV0dXJuIF9Db250cm9sbGVyLmludGVybmFscy51c2VSZWY7XG4gIH1cbiAgLyoqXG4gICAqIElmIHlvdSBuZWVkIHRvIHNldCBhIHByb3Avc3RhdGUgd2l0aG91dCB0cmlnZ2VyaW5nIHRoZSBjdXN0b20gc2V0dGVyIHlvdVxuICAgKiBkZWZpbmVkIHdpdGggZ2V0U2V0KCkvZHluYW1pY0dldFNldCgpL3JlYWRvbmx5KCksIHNldCB0aGUgdmFsdWUgaW5zaWRlXG4gICAqIG9mIHRoaXMgZnVuY3Rpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogQFByb3AoKSByZWFkT25seSA9IHRoaXMubWFuYWdlci5yZWFkT25seSh0cnVlKTtcbiAgICpcbiAgICogc29tZUFjdGlvbigpOiB2b2lkIHtcbiAgICogICB0aGlzLm1hbmFnZXIuYnlwYXNzU2V0dGVyKCgpPT57XG4gICAqICAgICB0aGlzLnJlYWRPbmx5ID0gZmFsc2U7XG4gICAqICAgfSk7XG4gICAqIH1cbiAgICpcbiAgICovXG4gIGJ5cGFzc1NldHRlcihjYWxsYmFjaykge1xuICAgIF9Db250cm9sbGVyLmludGVybmFscy5zaG91bGRCeXBhc3NTZXR0ZXIgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX0NvbnRyb2xsZXIuaW50ZXJuYWxzLnNob3VsZEJ5cGFzc1NldHRlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTGlrZSBieXBhc3NTZXR0ZXIsIGJ1dCBvbmx5IGJ5cGFzc2VzIHRoaXMubWFuYWdlci5yZWFkb25seSgpLCByYXRoZXIgdGhhdFxuICAgKiBhbGwgc2V0dGVycyBzZXQgdXNpbmcgdGhpcy5tYW5hZ2VyLmdldFNldCgpXG4gICAqL1xuICBieXBhc3NSZWFkb25seShjYWxsYmFjaykge1xuICAgIF9Db250cm9sbGVyLmludGVybmFscy5zaG91bGRCeXBhc3NSZWFkb25seSA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfQ29udHJvbGxlci5pbnRlcm5hbHMuc2hvdWxkQnlwYXNzUmVhZG9ubHkgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFByb3BlcnR5IHJlYWRzIGluc2lkZSBvZiB0aGlzIGZ1bmN0aW9uIHdpbGwgYnlwYXNzIGFueSBjdXN0b20gZ2V0dGVyIHlvdVxuICAgKiBtYXkgaGF2ZSwgYW5kIHJlYWQgdGhlIHZhbHVlIGRpcmVjdGx5IGZyb20gd2hhdCdzIHN0b3JlZCBpbiBTdGVuY2lsLlxuICAgKlxuICAgKiBUaGlzIGFsc28gYnlwYXNzZXMgcmVhY3RpdmVVdGlscyBpbnRlZ3JhdGlvbiAtIHJlYWRpbmcgYSBwcm9wZXJ0eSBpbnNpZGUgb2ZcbiAgICogYnlwYXNzR2V0dGVyIHdvbid0IG1ha2UgdGhhdCBwcm9wZXJ0eSB0cmFja2VkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiByZWFjdGl2ZVV0aWxzLndhdGNoKFxuICAgKiAgICgpPT57XG4gICAqICAgICB0aGlzLm1hbmFnZXIuYnlwYXNzR2V0dGVyKCgpPT57XG4gICAqICAgICAgIGNvbnNvbGUubG9nKHRoaXMuc29tZVByb3ApO1xuICAgKiAgICAgfSk7XG4gICAqICAgICByZXR1cm4gdGhpcy5wcm9wO1xuICAgKiAgIH0sXG4gICAqICAgY29uc29sZS5sb2dcbiAgICogKVxuICAgKi9cbiAgYnlwYXNzR2V0dGVyKGNhbGxiYWNrKSB7XG4gICAgX0NvbnRyb2xsZXIuaW50ZXJuYWxzLnNob3VsZEJ5cGFzc0dldHRlciA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfQ29udHJvbGxlci5pbnRlcm5hbHMuc2hvdWxkQnlwYXNzR2V0dGVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBMaWtlIHRoaXMubWFuYWdlci5nZXRTZXQoKSwgYnV0IGNhbiBiZSBjYWxsZWQgb24gYW55IGNvbXBvbmVudCdzXG4gICAqIHN0YXRlL3Byb3AgZnJvbSBhbnl3aGVyZSwgcmF0aGVyIHRoYW4ganVzdCBmcm9tIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAqL1xuICBkeW5hbWljR2V0U2V0KG5hbWUsIGdldFNldCkge1xuICAgIHRoaXMuZ2VuZXJpY0dldFNldChuYW1lLCBnZXRTZXQpO1xuICB9XG4gIC8qKlxuICAgKiBMaWtlIGR5bmFtaWNHZXRTZXQsIGJ1dCBsZXNzIHR5cGUtc2FmZS4gVXNlZnVsIGluIGNhc2VzIHdoZW4gdHJ5aW5nIHRvIHNldFxuICAgKiBnZXR0ZXJzL3NldHRlcnMgaW4gcGxhY2Ugd2hlcmUgcHJvcGVydHkgbmFtZXMgJiB0eXBlcyBhcmUgbm90IGtub3duXG4gICAqIHN0YXRpY2FsbHlcbiAgICovXG4gIGdlbmVyaWNHZXRTZXQocHJvcGVydHksIGdldFNldCkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIGNvbnN0IGdlbmVyaWNHZXRTZXQgPSBnZXRTZXQ7XG4gICAgaWYgKGdlbmVyaWNHZXRTZXQuZ2V0ICE9PSB2b2lkIDApIHtcbiAgICAgIChfYTIgPSB0aGlzLmludGVybmFscy5nZXR0ZXJzKVtwcm9wZXJ0eV0gPz8gKF9hMltwcm9wZXJ0eV0gPSBbXSk7XG4gICAgICB0aGlzLmludGVybmFscy5nZXR0ZXJzW3Byb3BlcnR5XS51bnNoaWZ0KGdlbmVyaWNHZXRTZXQuZ2V0KTtcbiAgICB9XG4gICAgaWYgKGdlbmVyaWNHZXRTZXQuc2V0ICE9PSB2b2lkIDApIHtcbiAgICAgIChfYiA9IHRoaXMuaW50ZXJuYWxzLnNldHRlcnMpW3Byb3BlcnR5XSA/PyAoX2JbcHJvcGVydHldID0gW10pO1xuICAgICAgdGhpcy5pbnRlcm5hbHMuc2V0dGVyc1twcm9wZXJ0eV0udW5zaGlmdChnZW5lcmljR2V0U2V0LnNldCk7XG4gICAgfVxuICB9XG4gIC8vIEZFQVRVUkU6IGltcHJvdmUgdHlwaW5nc1xuICAvKipcbiAgICogRHluYW1pY2FsbHkgc2V0IGEgd2F0Y2hlciBmb3IgYW55IFxcQFByb3AoKS9cXEBTdGF0ZSgpIHByb3BlcnR5XG4gICAqL1xuICB3YXRjaChwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IHR5cGUgPSBnZXRNZW1iZXJUeXBlKHRoaXMuY29tcG9uZW50LCBwcm9wZXJ0eSk7XG4gICAgaWYgKHR5cGUgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRyeWluZyB0byB3YXRjaCBhIG5vbi1AUHJvcCwgbm9uLUBTdGF0ZSBwcm9wZXJ0eSBcIiR7cHJvcGVydHl9XCIuIEVpdGhlciBjb252ZXJ0IGl0IGludG8gYSBAU3RhdGUoKSBvciB1c2UgbWFuYWdlci5nZXRTZXQvZHluYW1pY0dldFNldGBcbiAgICAgICk7XG4gICAgKF9hMiA9IHRoaXMuaW50ZXJuYWxzLmFsbFdhdGNoZXJzKVtwcm9wZXJ0eV0gPz8gKF9hMltwcm9wZXJ0eV0gPSBbXSk7XG4gICAgY29uc3Qgd2F0Y2hlcnMgPSB0aGlzLmludGVybmFscy5hbGxXYXRjaGVyc1twcm9wZXJ0eV07XG4gICAgY29uc3QgZ2VuZXJpY0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgY29uc3Qgc2FmZUNhbGxiYWNrID0gKG5ld1ZhbHVlLCBvbGRWYWx1ZSwgcHJvcGVydHlOYW1lKSA9PiBzYWZlQ2FsbCgoKSA9PiBnZW5lcmljQ2FsbGJhY2sobmV3VmFsdWUsIG9sZFZhbHVlLCBwcm9wZXJ0eU5hbWUpKTtcbiAgICB3YXRjaGVycy5wdXNoKHNhZmVDYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gd2F0Y2hlcnMuaW5kZXhPZihzYWZlQ2FsbGJhY2spO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgd2F0Y2hlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICB9XG4gIC8vIFJlZ2lzdGVyIGEgbGlmZWN5Y2xlIGNhbGxiYWNrXG4gIG9uQ29ubmVjdGVkKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzLmhvc3RDb25uZWN0ZWQucHVzaChjYWxsYmFjayk7XG4gIH1cbiAgb25EaXNjb25uZWN0ZWQoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9jYWxsYmFja3MuaG9zdERpc2Nvbm5lY3RlZC5wdXNoKGNhbGxiYWNrKTtcbiAgfVxuICBvbkxvYWQoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9jYWxsYmFja3MuaG9zdExvYWQucHVzaChjYWxsYmFjayk7XG4gIH1cbiAgb25Mb2FkZWQoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9jYWxsYmFja3MuaG9zdExvYWRlZC5wdXNoKGNhbGxiYWNrKTtcbiAgfVxuICBvblJlbmRlcihjYWxsYmFjaykge1xuICAgIHRoaXMuX2NhbGxiYWNrcy5ob3N0UmVuZGVyLnB1c2goY2FsbGJhY2spO1xuICB9XG4gIG9uUmVuZGVyZWQoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9jYWxsYmFja3MuaG9zdFJlbmRlcmVkLnB1c2goY2FsbGJhY2spO1xuICB9XG4gIG9uVXBkYXRlKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzLmhvc3RVcGRhdGUucHVzaChjYWxsYmFjayk7XG4gIH1cbiAgb25VcGRhdGVkKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzLmhvc3RVcGRhdGVkLnB1c2goY2FsbGJhY2spO1xuICB9XG4gIG9uRGVzdHJveShjYWxsYmFjaykge1xuICAgIHRoaXMuY29tcG9uZW50Lm1hbmFnZXIuZW5zdXJlSGFzRGVzdHJveSgpO1xuICAgIHRoaXMuX2NhbGxiYWNrcy5ob3N0RGVzdHJveS5wdXNoKGNhbGxiYWNrKTtcbiAgfVxuICBvbkxpZmVjeWNsZShjYWxsYmFjaykge1xuICAgIHRoaXMuX2NhbGxiYWNrcy5ob3N0TGlmZWN5Y2xlLnB1c2goY2FsbGJhY2spO1xuICAgIGlmICh0aGlzLmNvbm5lY3RlZENhbGxlZCAmJiB0aGlzLmNvbXBvbmVudC5lbC5pc0Nvbm5lY3RlZClcbiAgICAgIHRoaXMuX2NhbGxMaWZlY3ljbGUoY2FsbGJhY2spO1xuICB9XG4gIC8vIENhbGwgZWFjaCBsaWZlY3ljbGUgaG9va1xuICB0cmlnZ2VyQ29ubmVjdGVkKCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcy5ob3N0Q29ubmVjdGVkLmZvckVhY2goc2FmZUNhbGwpO1xuICAgIHRoaXMudHJpZ2dlckxpZmVjeWNsZSgpO1xuICAgIHRoaXMuY29ubmVjdGVkQ2FsbGVkID0gdHJ1ZTtcbiAgfVxuICB0cmlnZ2VyRGlzY29ubmVjdGVkKCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcy5ob3N0RGlzY29ubmVjdGVkLmZvckVhY2goc2FmZUNhbGwpO1xuICAgIHRoaXMuX2xpZmVjeWNsZURpc2Nvbm5lY3RlZC5mb3JFYWNoKHNhZmVDYWxsKTtcbiAgICB0aGlzLl9saWZlY3ljbGVEaXNjb25uZWN0ZWQgPSBbXTtcbiAgfVxuICBhc3luYyB0cmlnZ2VyTG9hZCgpIHtcbiAgICBpZiAodGhpcy53aWxsTG9hZENhbGxlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLndpbGxMb2FkQ2FsbGVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5fY2FsbGJhY2tzLmhvc3RMb2FkLmxlbmd0aCA+IDApXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQodGhpcy5fY2FsbGJhY2tzLmhvc3RMb2FkLm1hcChzYWZlQXN5bmNDYWxsKSk7XG4gICAgdGhpcy5fcmVhZHkucmVzb2x2ZSh0aGlzLl9leHBvcnRzKTtcbiAgfVxuICB0cmlnZ2VyTG9hZGVkKCkge1xuICAgIGlmICh0aGlzLmRpZExvYWRDYWxsZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fY2FsbGJhY2tzLmhvc3RMb2FkZWQuZm9yRWFjaChzYWZlQ2FsbCk7XG4gICAgdGhpcy5kaWRMb2FkQ2FsbGVkID0gdHJ1ZTtcbiAgfVxuICBhc3luYyB0cmlnZ2VyUmVuZGVyKCkge1xuICAgIGlmICh0aGlzLl9jYWxsYmFja3MuaG9zdFJlbmRlci5sZW5ndGggPiAwKVxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHRoaXMuX2NhbGxiYWNrcy5ob3N0UmVuZGVyLm1hcChzYWZlQXN5bmNDYWxsKSk7XG4gIH1cbiAgdHJpZ2dlclJlbmRlcmVkKCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcy5ob3N0UmVuZGVyZWQuZm9yRWFjaChzYWZlQ2FsbCk7XG4gIH1cbiAgYXN5bmMgdHJpZ2dlclVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fY2FsbGJhY2tzLmhvc3RVcGRhdGUubGVuZ3RoID4gMClcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZCh0aGlzLl9jYWxsYmFja3MuaG9zdFVwZGF0ZS5tYXAoc2FmZUFzeW5jQ2FsbCkpO1xuICB9XG4gIHRyaWdnZXJVcGRhdGVkKCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcy5ob3N0VXBkYXRlZC5mb3JFYWNoKHNhZmVDYWxsKTtcbiAgfVxuICB0cmlnZ2VyRGVzdHJveSgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MuaG9zdERlc3Ryb3kuZm9yRWFjaChzYWZlQ2FsbCk7XG4gIH1cbiAgdHJpZ2dlckxpZmVjeWNsZSgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MuaG9zdExpZmVjeWNsZS5mb3JFYWNoKChjYWxsYmFjaykgPT4gdGhpcy5fY2FsbExpZmVjeWNsZShjYWxsYmFjaykpO1xuICB9XG4gIF9jYWxsTGlmZWN5Y2xlKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY2xlYW51cFJhdyA9IHNhZmVDYWxsKGNhbGxiYWNrKTtcbiAgICBjb25zdCBjbGVhbnVwID0gQXJyYXkuaXNBcnJheShjbGVhbnVwUmF3KSA/IGNsZWFudXBSYXcgOiBbY2xlYW51cFJhd107XG4gICAgY2xlYW51cC5mb3JFYWNoKChjbGVhbnVwMikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBjbGVhbnVwMiA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aGlzLl9saWZlY3ljbGVEaXNjb25uZWN0ZWQucHVzaChjbGVhbnVwMik7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgY2xlYW51cDIgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNsZWFudXAyLnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aGlzLl9saWZlY3ljbGVEaXNjb25uZWN0ZWQucHVzaChjbGVhbnVwMi5yZW1vdmUpO1xuICAgIH0pO1xuICB9XG59O1xuX2EgPSBjb250cm9sbGVyU3ltYm9sO1xuX0NvbnRyb2xsZXIuaW50ZXJuYWxzID0gbmV3IENvbnRyb2xsZXJJbnRlcm5hbHMoKTtcbnZhciBDb250cm9sbGVyID0gX0NvbnRyb2xsZXI7XG52YXIgR2VuZXJpY0NvbnRyb2xsZXIgPSBjbGFzcyBleHRlbmRzIENvbnRyb2xsZXIge1xuICAvLyBSZWR1bmRhbnQgY29uc3RydWN0b3IgbmVlZGVkIHRvIGltcHJvdmUgdHlwaW5nXG4gIGNvbnN0cnVjdG9yKGNvbXBvbmVudCkge1xuICAgIHN1cGVyKGNvbXBvbmVudCk7XG4gIH1cbiAgLy8gT3ZlcnJpZGluZyBzdXBlcidzIHdhdGNoIG9ubHkgdG8gaW1wcm92ZSB0eXBpbmdcbiAgd2F0Y2gocHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHN1cGVyLndhdGNoKFxuICAgICAgcHJvcGVydHksXG4gICAgICBjYWxsYmFja1xuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFNpbGVuY2UgXCJQcm9wZXJ0eSAnZHluYW1pY0dldFNldCcgaW4gdHlwZVxuICAgKiAnR2VuZXJpY0NvbnRyb2xsZXI8RXhwb3J0cywgUmVxdWlyZXM+JyBpcyBub3QgYXNzaWduYWJsZSB0byB0aGUgc2FtZVxuICAgKiBwcm9wZXJ0eSBpbiBiYXNlIHR5cGUgJ0NvbnRyb2xsZXI8RXhwb3J0cz4nXCIsIGFzIFR5cGVTY3JpcHQgaXMgYmVpbmcgb3Zlcmx5XG4gICAqIGNvbnNlcnZhdGl2ZSBoZXJlIHdpdGggd2hhdCBpdCBhbGxvd3NcbiAgICovXG4gIGR5bmFtaWNHZXRTZXQocHJvcGVydHksIGdldFNldCkge1xuICAgIHN1cGVyLmdlbmVyaWNHZXRTZXQocHJvcGVydHksIGdldFNldCk7XG4gIH1cbn07XG5mdW5jdGlvbiBtYWtlUHJvdmlzaW9uYWxWYWx1ZShiYXNlKSB7XG4gIGlmICh0eXBlb2YgYmFzZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYmFzZSAhPT0gXCJmdW5jdGlvblwiIHx8IGJhc2UgPT09IG51bGwpXG4gICAgcmV0dXJuIGJhc2U7XG4gIGNvbnN0IHByb3h5MyA9IG5ldyBQcm94eShiYXNlLCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIGlmIChjeWNsaWNhbC5oYXMocHJvcCkgJiYgcHJvcCBpbiB0YXJnZXQgJiYgdGFyZ2V0W3Byb3BdID09PSBwcm94eTMpXG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICBpZiAocHJvcCBpbiB0YXJnZXQgfHwgcHJvcCBpbiBQcm9taXNlLnByb3RvdHlwZSB8fCB0eXBlb2YgcHJvcCA9PT0gXCJzeW1ib2xcIilcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRhcmdldFtwcm9wXSA6IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgY29uc29sZS5lcnJvcihgVHJ5aW5nIHRvIGFjY2VzcyBcIiR7cHJvcC50b1N0cmluZygpfVwiIG9uIHRoZSBjb250cm9sbGVyIGJlZm9yZSBpdCdzIGxvYWRlZC4gJHthY2Nlc3NCZWZvcmVMb2FkfWApO1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIG5ld1ZhbHVlLCByZWNlaXZlcikge1xuICAgICAgY29uc29sZS5lcnJvcihgVHJ5aW5nIHRvIHNldCBcIiR7cHJvcC50b1N0cmluZygpfVwiIG9uIHRoZSBjb250cm9sbGVyIGJlZm9yZSBpdCdzIGxvYWRlZC4gJHthY2Nlc3NCZWZvcmVMb2FkfWApO1xuICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcCwgbmV3VmFsdWUsIHJlY2VpdmVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcHJveHkzO1xufVxudmFyIGN5Y2xpY2FsID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiZXhwb3J0c1wiLCBcIl9leHBvcnRzXCJdKTtcbnZhciBhY2Nlc3NCZWZvcmVMb2FkID0gW1xuICBcIlRoaXMgbWlnaHQgYmUgdGhlIGNhc2UgaWYgeW91IGFyZSB0cnlpbmcgdG8gYWNjZXNzIGFuIGFzeW5jIGNvbnRyb2xsZXIgaW4gXCIsXG4gIFwiY29ubmVjdGVkQ2FsbGJhY2soKS4gT3IsIGlmIHlvdSBhcmUgdXNpbmcgaXQgaW5zaWRlIG9mIFwiLFxuICBcImNvbXBvbmVudFdpbGxMb2FkKCkvYW5vdGhlciBjb250cm9sbGVyIHdpdGhvdXQgY29udHJvbGxlci51c2UuIEV4YW1wbGUgY29ycmVjdCBcIixcbiAgXCJ1c2FnZTpcXG5cIixcbiAgXCJtYWtlQ29udHJvbGxlcihhc3luYyAoY29tcG9uZW50LCBjb250cm9sbGVyKT0+eyBhd2FpdCBjb250cm9sbGVyLnVzZShzb21lT3RoZXJDb250cm9sbGVyKTsgfSk7XCJcbl0uam9pbihcIlwiKTtcbmZ1bmN0aW9uIHRvQ29udHJvbGxlckhvc3QoY29tcG9uZW50KSB7XG4gIGlmIChcImFkZENvbnRyb2xsZXJcIiBpbiBjb21wb25lbnQpXG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiQ29tcG9uZW50IGRvZXMgbm90IGltcGxlbWVudCBDb250cm9sbGVySG9zdC4gVGhpcyBtaWdodCBiZSBiZWNhdXNlIHlvdSBmb3Jnb3QgdG8gYWRkICdtYW5hZ2VyOiBDb250cm9sbGVyPHRoaXM+ID0gdXNlQ29udHJvbGxlck1hbmFnZXIodGhpcyk7JyBpbiB5b3VyIGNvbXBvbmVudCwgb3IgeW91IHRyaWVkIHRvIHVzZSBzb21lIGNvbnRyb2xsZXIgYmVmb3JlIHRoYXQgbGluZVwiXG4gICAgKTtcbn1cblxuLy8gc3JjL3RyYWNrUHJvcGVydHlLZXkudHNcbmZ1bmN0aW9uIHRyYWNrUHJvcGVydHlLZXkob2JqZWN0LCBvblJlc29sdmVkLCBkZWZhdWx0VmFsdWUpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGNvbnN0IGtleUNvdW50ID0ga2V5cy5sZW5ndGg7XG4gIGlmIChrZXlUcmFja01hcCA9PT0gdm9pZCAwKVxuICAgIHF1ZXVlTWljcm90YXNrKGtleVRyYWNrUmVzb2x2ZSk7XG4gIGtleVRyYWNrTWFwID8/IChrZXlUcmFja01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICBsZXQgcGVuZGluZ1RyYWNrZXJzID0ga2V5VHJhY2tNYXAuZ2V0KG9iamVjdCk7XG4gIGlmIChwZW5kaW5nVHJhY2tlcnMgPT09IHZvaWQgMCkge1xuICAgIHBlbmRpbmdUcmFja2VycyA9IHsgY2FsbGJhY2tzOiBbXSwga2V5Q291bnQgfTtcbiAgICBrZXlUcmFja01hcC5zZXQob2JqZWN0LCBwZW5kaW5nVHJhY2tlcnMpO1xuICB9XG4gIGlmIChwZW5kaW5nVHJhY2tlcnMua2V5Q291bnQgIT09IGtleUNvdW50KSB7XG4gICAgcGVuZGluZ1RyYWNrZXJzLmNhbGxiYWNrcy5mb3JFYWNoKChyZXNvbHZlKSA9PiByZXNvbHZlKGtleXMpKTtcbiAgICBwZW5kaW5nVHJhY2tlcnMuY2FsbGJhY2tzID0gW107XG4gICAgcGVuZGluZ1RyYWNrZXJzLmtleUNvdW50ID0ga2V5Q291bnQ7XG4gIH1cbiAgcGVuZGluZ1RyYWNrZXJzLmNhbGxiYWNrcy5wdXNoKChrZXlzMikgPT4ge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gKGtleTIpID0+IHNhZmVDYWxsKCgpID0+IG9uUmVzb2x2ZWQoa2V5MikpO1xuICAgIGNvbnN0IGtleSA9IGtleXMyW2tleUNvdW50XTtcbiAgICBpZiAoa2V5ID09PSB2b2lkIDApXG4gICAgICBjYWxsYmFjayh2b2lkIDApO1xuICAgIGVsc2UgaWYgKG9iamVjdFtrZXldID09PSBkZWZhdWx0VmFsdWUpXG4gICAgICBjYWxsYmFjayhrZXkpO1xuICAgIGVsc2VcbiAgICAgIGNhbGxiYWNrKHZvaWQgMCk7XG4gIH0pO1xuICByZXR1cm4gZGVmYXVsdFZhbHVlO1xufVxudmFyIGtleVRyYWNrTWFwID0gdm9pZCAwO1xuZnVuY3Rpb24ga2V5VHJhY2tSZXNvbHZlKCkge1xuICBBcnJheS5mcm9tKGtleVRyYWNrTWFwPy5lbnRyaWVzKCkgPz8gW10pLmZvckVhY2goKFtvYmplY3QsIHsgY2FsbGJhY2tzIH1dKSA9PiB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgY2FsbGJhY2tzLmZvckVhY2goKGNvbW1pdCkgPT4gY29tbWl0KGtleXMpKTtcbiAgfSk7XG4gIGtleVRyYWNrTWFwID0gdm9pZCAwO1xufVxuXG4vLyBzcmMvQ29tcG9uZW50SW50ZXJuYWxzLnRzXG52YXIgQ29tcG9uZW50SW50ZXJuYWxzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb21wb25lbnQpIHtcbiAgICAvKipcbiAgICAgKiBXaGVuIHdhdGNoZXJzIGFyZSBzZXQsIHNldCB0aGVuIGludG8gYGFsbFdhdGNoZXJzYC4gV2hlbiB3YXRjaGVycyBhcmUgcmVhZFxuICAgICAqIGluIHRoZSBzZXR0ZXIsIHJlYWQgZnJvbSBgZW5hYmxlZFdhdGNoZXJzYC5cbiAgICAgKiBPbiBjb25uZWN0ZWRDYWxsYmFjaygpLCBjb250cm9sbGVyIG1hbmFnZXIgZG9lcyBgZW5hYmxlZFdhdGNoZXJzPWFsbFdhdGNoZXJzYC5cbiAgICAgKiBSZWFzb25pbmc6XG4gICAgICogLSBUaGlzIGRpc2FibGVzIHdhdGNoZXJzIHVudGlsIGNvbm5lY3RlZCBjYWxsYmFjayAobWF0Y2hlcyBiZWhhdmlvciBvZlxuICAgICAqICAgU3RlbmNpbCdzIHdhdGNoZXJzKVxuICAgICAqIC0gVGhpcyByZW1vdmVzIGluIHRoZSBzZXR0ZXIgdG8gY2hlY2sgaWYgd2F0Y2hlcnMgd2VyZSBlbmFibGVkIGFscmVhZHkgb3JcbiAgICAgKiAgIG5vdCAoYXMgZ2V0dGVycy9zZXR0ZXJzIGFyZSBob3QgcGF0aCwgYW5kIHNob3VsZCBiZSBzdHJlYW1saW5lZClcbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZWRXYXRjaGVycyA9IHt9O1xuICAgIHRoaXMuYWxsV2F0Y2hlcnMgPSB7fTtcbiAgICB0aGlzLnRyYWNrS2V5ID0gKGhvc3RzQ2FuZGlkYXRlcywgb25SZXNvbHZlZCwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBjYW5kaWRhdGVIb3N0cyA9IEFycmF5LmlzQXJyYXkoaG9zdHNDYW5kaWRhdGVzKSA/IGhvc3RzQ2FuZGlkYXRlcyA6IFtob3N0c0NhbmRpZGF0ZXNdO1xuICAgICAgbGV0IGxlZnRUb1Jlc29sdmUgPSBjYW5kaWRhdGVIb3N0cy5sZW5ndGggKyAxO1xuICAgICAgY29uc3QgcmVzb2x2ZWQgPSAocmVzb2x1dGlvbikgPT4ge1xuICAgICAgICBsZWZ0VG9SZXNvbHZlIC09IDE7XG4gICAgICAgIGlmIChyZXNvbHV0aW9uICE9PSB2b2lkIDApXG4gICAgICAgICAgbGVmdFRvUmVzb2x2ZSA9IDA7XG4gICAgICAgIGlmIChsZWZ0VG9SZXNvbHZlID09PSAwKVxuICAgICAgICAgIG9uUmVzb2x2ZWQocmVzb2x1dGlvbik7XG4gICAgICB9O1xuICAgICAgY2FuZGlkYXRlSG9zdHMuZm9yRWFjaChcbiAgICAgICAgKGhvc3QpID0+IHRoaXMuY29tcG9uZW50Lm1hbmFnZXIudHJhY2tQcm9wZXJ0eUtleShcbiAgICAgICAgICBob3N0LFxuICAgICAgICAgIChrZXkpID0+IHJlc29sdmVkKFxuICAgICAgICAgICAga2V5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB7XG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgaG9zdCxcbiAgICAgICAgICAgICAgdHlwZTogXCJwcm9wZXJ0eVwiLFxuICAgICAgICAgICAgICBkb21WYWx1ZTogdm9pZCAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICBkZWZhdWx0VmFsdWVcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRoaXMuY29tcG9uZW50Lm1hbmFnZXIudHJhY2tQcm9wS2V5KChrZXksIGRvbVZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb3BUeXBlID0ga2V5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXRQcm9wVHlwZSh0aGlzLmNvbXBvbmVudCwga2V5KTtcbiAgICAgICAgcmVzb2x2ZWQoXG4gICAgICAgICAga2V5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBob3N0OiB0aGlzLmNvbXBvbmVudCxcbiAgICAgICAgICAgIHR5cGU6IHByb3BUeXBlID8/IFwicHJvcFwiLFxuICAgICAgICAgICAgZG9tVmFsdWU6IHByb3BUeXBlID09PSBcInByb3BcIiA/IGRvbVZhbHVlIDogdm9pZCAwXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfTtcbiAgICB0aGlzLnRyYWNrUHJvcEtleSA9IChvblJlc29sdmVkLCBkZWZhdWx0VmFsdWUsIGlnbm9yZURlZmF1bHRWYWx1ZU1pc21hdGNoID0gZmFsc2UpID0+IHtcbiAgICAgIGlmICh0aGlzLl90cmFja2VkVmFsdWUgIT09IG5vdGhpbmcgJiYgdGhpcy5fdHJhY2tlZFZhbHVlICE9PSBkZWZhdWx0VmFsdWUpXG4gICAgICAgIHRoaXMuX2ZpcmVQcm9wZXJ0eVRyYWNrZXJzKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDApO1xuICAgICAgaWYgKHRoaXMuX2tleVRyYWNrZXJzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gdGhpcy5fZmlyZVByb3BlcnR5VHJhY2tlcnModm9pZCAwLCB2b2lkIDAsIHZvaWQgMCkpO1xuICAgICAgdGhpcy5fdHJhY2tlZFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgdGhpcy5fa2V5VHJhY2tlcnMucHVzaChcbiAgICAgICAgKGtleSwgdmFsdWUsIHByZXZpb3VzVmFsdWUpID0+IHNhZmVDYWxsKFxuICAgICAgICAgICgpID0+IG9uUmVzb2x2ZWQoZGVmYXVsdFZhbHVlID09PSB2YWx1ZSB8fCBpZ25vcmVEZWZhdWx0VmFsdWVNaXNtYXRjaCA/IGtleSA6IHZvaWQgMCwgcHJldmlvdXNWYWx1ZSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfTtcbiAgICB0aGlzLl90cmFja2VkVmFsdWUgPSBub3RoaW5nO1xuICAgIHRoaXMuX2tleVRyYWNrZXJzID0gW107XG4gICAgdGhpcy5nZXR0ZXJzID0ge307XG4gICAgdGhpcy5zZXR0ZXJzID0ge307XG4gICAgdGhpcy5hY2Nlc3NvckdldHRlciA9IHt9O1xuICAgIHRoaXMuYWNjZXNzb3JTZXR0ZXIgPSB7fTtcbiAgICB0aGlzLl9leHBvcnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29tcG9uZW50XCIsIHtcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGNvbXBvbmVudFxuICAgIH0pO1xuICB9XG4gIF9maXJlUHJvcGVydHlUcmFja2VycyhrZXksIHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIGNvbnN0IHRyYWNrZXJzID0gdGhpcy5fa2V5VHJhY2tlcnM7XG4gICAgdGhpcy5fdHJhY2tlZFZhbHVlID0gbm90aGluZztcbiAgICB0aGlzLl9rZXlUcmFja2VycyA9IFtdO1xuICAgIHRyYWNrZXJzLmZvckVhY2goKHRyYWNrZXIpID0+IHRyYWNrZXIoa2V5LCB2YWx1ZSwgb2xkVmFsdWUpKTtcbiAgfVxuICAvKipcbiAgICogQ29uZmlndXJlIGEgZ2V0dGVyIG9yIHNldHRlciBmb3IgYSBnaXZlbiBcXEBQcm9wL1xcQFN0YXRlXG4gICAqXG4gICAqIE5vdGUsIHNpbmNlIHByb3BzIGFyZSBkZWZpbmVkIG9uIHRoZSBwcm90b3R5cGUsIHRoZXkgYXJlIHNoYXJlZCBiZXR3ZWVuIGFsbFxuICAgKiBpbnN0YW5jZXMgb2YgYSBjb21wb25lbnQuIFRodXMsIGluc3RlYWQgb2YgcGFzc2luZyBhIHJlZmVyZW5jZSB0byB0aGVcbiAgICogZ2V0dGVyL3NldHRlciBmdW5jdGlvbiwgeW91IHNob3VsZCB1cGRhdGUgdGhlXG4gICAqIENvbXBvbmVudEludGVybmFscy5nZXR0ZXJzL3NldHRlcnMgcHJvcGVydGllcywgYW5kIHRoZW4gY2FsbCBnZXRTZXRQcm94eVxuICAgKiB0byBhcHBseSB0aGUgY2hhbmdlcyB0byB0aGUgcHJvdG90eXBlXG4gICAqL1xuICBnZXRTZXRQcm94eShwcm9wZXJ0eSwgaGFzR2V0dGVyLCBoYXNTZXR0ZXIpIHtcbiAgICBjb25zdCBjbGFzc1Byb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzLmNvbXBvbmVudCk7XG4gICAgdGhpcy5fZ2V0U2V0UHJveHkoY2xhc3NQcm90b3R5cGUsIHByb3BlcnR5LCBoYXNHZXR0ZXIsIGhhc1NldHRlciwgXCJjbGFzc1wiKTtcbiAgICBjb25zdCBodG1sUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMuY29tcG9uZW50LmVsKTtcbiAgICBpZiAoY2xhc3NQcm90b3R5cGUgIT09IGh0bWxQcm90b3R5cGUpXG4gICAgICB0aGlzLl9nZXRTZXRQcm94eShodG1sUHJvdG90eXBlLCBwcm9wZXJ0eSwgaGFzR2V0dGVyLCBoYXNTZXR0ZXIsIFwiaHRtbFwiKTtcbiAgfVxuICBfZ2V0U2V0UHJveHkocHJvdG90eXBlLCBuYW1lLCBoYXNHZXR0ZXIsIGhhc1NldHRlciwgdHlwZSkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgIGNvbnN0IHByb3BUeXBlID0gZ2V0TWVtYmVyVHlwZShjb21wb25lbnQsIG5hbWUpO1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvdHlwZSwgbmFtZSk7XG4gICAgY29uc3QgdG9sZXJhdGVOb3RGb3VuZCA9IHR5cGUgPT09IFwiaHRtbFwiO1xuICAgIGlmIChkZXNjcmlwdG9yPy5zZXQgPT09IHZvaWQgMCB8fCBkZXNjcmlwdG9yLmdldCA9PT0gdm9pZCAwKVxuICAgICAgaWYgKGRlc2NyaXB0b3IgIT09IHZvaWQgMCAmJiBcInZhbHVlXCIgaW4gZGVzY3JpcHRvcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBnZXRTZXQoKSBzaG91bGQgb25seSBiZSB1c2VkIG9uIFN0ZW5jaWwncyBAUHJvcCBhbmQgQFN0YXRlIHByb3BlcnRpZXMuIEZvciBpbnRlcm5hbCBjb21wb25lbnQgcHJvcGVydGllcywgdXNlIHJlZ3VsYXIgZ2V0L3NldCBzeW50YXguIFRyaWVkIHRvIHVzZSBpdCBvbiBcIiR7bmFtZX1cIiBpbiAke2NvbXBvbmVudC5lbC50YWdOYW1lfWBcbiAgICAgICAgKTtcbiAgICAgIGVsc2UgaWYgKHRvbGVyYXRlTm90Rm91bmQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBcIiR7bmFtZX1cIiBwcm9wZXJ0eSBvbiB0aGUgJHtjb21wb25lbnQuZWwudGFnTmFtZX0gY29tcG9uZW50YCk7XG4gICAgY29uc3QgeyBnZXQ6IG9yaWdpbmFsR2V0LCBzZXQ6IG9yaWdpbmFsU2V0IH0gPSBkZXNjcmlwdG9yO1xuICAgIGNvbnN0IGlzR2V0dGVyQWxyZWFkeU92ZXJ3cml0dGVuID0gY3VzdG9tQWNjZXNzb3IgaW4gb3JpZ2luYWxHZXQ7XG4gICAgY29uc3QgaXNTZXR0ZXJBbHJlYWR5T3ZlcndyaXR0ZW4gPSBjdXN0b21BY2Nlc3NvciBpbiBvcmlnaW5hbFNldDtcbiAgICBjb25zdCBzaG91bGRPdmVyd3JpdGVHZXQgPSAhaXNHZXR0ZXJBbHJlYWR5T3ZlcndyaXR0ZW4gJiYgaGFzR2V0dGVyO1xuICAgIGNvbnN0IHNob3VsZE92ZXJ3cml0ZVNldCA9ICFpc1NldHRlckFscmVhZHlPdmVyd3JpdHRlbiAmJiBoYXNTZXR0ZXI7XG4gICAgaWYgKCFzaG91bGRPdmVyd3JpdGVHZXQgJiYgIXNob3VsZE92ZXJ3cml0ZVNldClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBmaW5hbEdldHRlciA9IHNob3VsZE92ZXJ3cml0ZUdldCA/IGZ1bmN0aW9uIGdldHRlcigpIHtcbiAgICAgIGxldCB2YWx1ZSA9IG9yaWdpbmFsR2V0LmNhbGwodGhpcyk7XG4gICAgICBjb25zdCBjb21wb25lbnQyID0gQ29udHJvbGxlci5pbnRlcm5hbHMuZWxlbWVudFRvSW5zdGFuY2UuZ2V0KHRoaXMpO1xuICAgICAgaWYgKENvbnRyb2xsZXIuaW50ZXJuYWxzLnNob3VsZEJ5cGFzc0dldHRlciB8fCBjb21wb25lbnQyID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIGNvbnN0IGludGVybmFscyA9IGNvbXBvbmVudDIubWFuYWdlci5pbnRlcm5hbHM7XG4gICAgICB2YWx1ZSA9IGludGVybmFscy5hY2Nlc3NvckdldHRlcltuYW1lXSh2YWx1ZSwgbmFtZSk7XG4gICAgICBjb25zdCBnZXR0ZXJzID0gaW50ZXJuYWxzLmdldHRlcnNbbmFtZV0gPz8gZW1wdHlBcnJheTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2V0dGVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgdmFsdWUgPSBnZXR0ZXJzW2ldKHZhbHVlLCBuYW1lKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IDogb3JpZ2luYWxHZXQ7XG4gICAgY29uc3QgZmluYWxTZXR0ZXIgPSBzaG91bGRPdmVyd3JpdGVTZXQgPyBmdW5jdGlvbiBzZXR0ZXIocmF3TmV3VmFsdWUpIHtcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gb3JpZ2luYWxHZXQuY2FsbCh0aGlzKTtcbiAgICAgIGxldCBuZXdWYWx1ZSA9IHBhcnNlUHJvcGVydHlWYWx1ZShyYXdOZXdWYWx1ZSwgcHJvcFR5cGUpO1xuICAgICAgY29uc3QgY29tcG9uZW50MiA9IENvbnRyb2xsZXIuaW50ZXJuYWxzLmVsZW1lbnRUb0luc3RhbmNlLmdldCh0aGlzKTtcbiAgICAgIGlmIChjb21wb25lbnQyID09PSB2b2lkIDApIHtcbiAgICAgICAgb3JpZ2luYWxTZXQuY2FsbCh0aGlzLCByYXdOZXdWYWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGludGVybmFscyA9IGNvbXBvbmVudDIubWFuYWdlci5pbnRlcm5hbHM7XG4gICAgICBpZiAobmV3VmFsdWUgPT09IG9sZFZhbHVlKVxuICAgICAgICBvcmlnaW5hbFNldC5jYWxsKHRoaXMsIHJhd05ld1ZhbHVlKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzZXR0ZXJzID0gQ29udHJvbGxlci5pbnRlcm5hbHMuc2hvdWxkQnlwYXNzU2V0dGVyID8gZW1wdHlBcnJheSA6IGludGVybmFscy5zZXR0ZXJzW25hbWVdID8/IGVtcHR5QXJyYXk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0dGVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICBuZXdWYWx1ZSA9IHNldHRlcnNbaV0obmV3VmFsdWUsIG9sZFZhbHVlLCBuYW1lKTtcbiAgICAgICAgbmV3VmFsdWUgPSBpbnRlcm5hbHMuYWNjZXNzb3JTZXR0ZXJbbmFtZV0obmV3VmFsdWUsIG9sZFZhbHVlLCBuYW1lKTtcbiAgICAgICAgb3JpZ2luYWxTZXQuY2FsbCh0aGlzLCBuZXdWYWx1ZSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpXG4gICAgICAgICAgaW50ZXJuYWxzLmVuYWJsZWRXYXRjaGVyc1tuYW1lXT8uZm9yRWFjaCgod2F0Y2hlcikgPT4gd2F0Y2hlcihuZXdWYWx1ZSwgb2xkVmFsdWUsIG5hbWUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnRlcm5hbHMuX2tleVRyYWNrZXJzLmxlbmd0aCA+IDApXG4gICAgICAgIGludGVybmFscz8uX2ZpcmVQcm9wZXJ0eVRyYWNrZXJzKG5hbWUsIHJhd05ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgfSA6IG9yaWdpbmFsU2V0O1xuICAgIGlmIChzaG91bGRPdmVyd3JpdGVHZXQpXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmluYWxHZXR0ZXIsIGN1c3RvbUFjY2Vzc29yLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGlmIChzaG91bGRPdmVyd3JpdGVTZXQpXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmluYWxTZXR0ZXIsIGN1c3RvbUFjY2Vzc29yLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG5hbWUsIHtcbiAgICAgIC4uLmRlc2NyaXB0b3IsXG4gICAgICBnZXQ6IGZpbmFsR2V0dGVyLFxuICAgICAgc2V0OiBmaW5hbFNldHRlclxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBc3NvY2lhdGUgYW4gZXhwb3J0cyBvYmplY3Qgd2l0aCBhIGNvbnRyb2xsZXIgZm9yIHJldmVyc2UgbG9va3VwIGluXG4gICAqIGNvbnRyb2xsZXIudXNlXG4gICAqL1xuICBtYXJrRXhwb3J0cyhjb250cm9sbGVyLCBleHBvcnRzKSB7XG4gICAgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICYmIGV4cG9ydHMgIT09IG51bGwgfHwgdHlwZW9mIGV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHRoaXMuX2V4cG9ydHMuc2V0KGV4cG9ydHMsIGNvbnRyb2xsZXIpO1xuICB9XG4gIHJlc29sdmVFeHBvcnRzKGV4cG9ydHMpIHtcbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgZXhwb3J0cyAhPT0gbnVsbCB8fCB0eXBlb2YgZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgcmV0dXJuIHRoaXMuX2V4cG9ydHMuZ2V0KGV4cG9ydHMpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn07XG52YXIgZW1wdHlBcnJheSA9IFtdO1xudmFyIGN1c3RvbUFjY2Vzc29yID0gU3ltYm9sKFwiY29udHJvbGxlcnNDdXN0b21BY2Nlc3NvclwiKTtcbnZhciBub3RoaW5nID0gU3ltYm9sKFwibm90aGluZ1wiKTtcbnZhciBhY2Nlc3NvclByb21pc2UgPSBQcm9taXNlLmFsbChbaW1wb3J0Q29yZUFjY2Vzc29yKCksIGltcG9ydENvcmVBY2Nlc3NvclN1cHBvcnREZWNvcmF0b3JzKCldKTtcbmZ1bmN0aW9uIHJlYWN0aXZlVXRpbHNJbnRlZ3JhdGlvbihjb21wb25lbnQpIHtcbiAgY29uc3QgbWVtYmVycyA9IGdldFByb3BMaWtlTWVtYmVycyhjb21wb25lbnQpO1xuICBjb25zdCBpbnRlcm5hbHMgPSBjb21wb25lbnQubWFuYWdlci5pbnRlcm5hbHM7XG4gIG1lbWJlcnMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIGludGVybmFscy5hY2Nlc3NvckdldHRlcltuYW1lXSA9IGRlZmF1bHRHZXR0ZXJTZXR0ZXI7XG4gICAgaW50ZXJuYWxzLmFjY2Vzc29yU2V0dGVyW25hbWVdID0gZGVmYXVsdEdldHRlclNldHRlcjtcbiAgICBpbnRlcm5hbHMuZ2V0U2V0UHJveHkobmFtZSwgdHJ1ZSwgdHJ1ZSk7XG4gIH0pO1xuICByZXR1cm4gYXN5bmMgKGVuYWJsZWRNZW1iZXJzID0gbWVtYmVycykgPT4ge1xuICAgIGNvbnN0IFtBY2Nlc3NvciwgeyBzdWJjbGFzcywgcHJvcGVydHkgfV0gPSBhd2FpdCBhY2Nlc3NvclByb21pc2U7XG4gICAgY2xhc3MgQWNjZXNzb3JTdWJjbGFzcyBleHRlbmRzIEFjY2Vzc29yIHtcbiAgICB9XG4gICAgY29uc3QgZ2V0dGVyID0gKF92YWx1ZSwgcHJvcGVydHlOYW1lKSA9PiBhY2Nlc3Nvcltwcm9wZXJ0eU5hbWVdO1xuICAgIGZ1bmN0aW9uIHNldHRlcihuZXdWYWx1ZSwgX29sZFZhbHVlLCBwcm9wZXJ0eU5hbWUpIHtcbiAgICAgIGlmIChhY2Nlc3NvciAhPT0gdm9pZCAwKVxuICAgICAgICBhY2Nlc3Nvcltwcm9wZXJ0eU5hbWVdID0gbmV3VmFsdWU7XG4gICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgfVxuICAgIGNvbXBvbmVudC5tYW5hZ2VyLmJ5cGFzc0dldHRlcihcbiAgICAgICgpID0+IGVuYWJsZWRNZW1iZXJzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgaW50ZXJuYWxzLmFjY2Vzc29yR2V0dGVyW25hbWVdID0gZ2V0dGVyO1xuICAgICAgICBpbnRlcm5hbHMuYWNjZXNzb3JTZXR0ZXJbbmFtZV0gPSBzZXR0ZXI7XG4gICAgICAgIHByb3BlcnR5KHtcbiAgICAgICAgICB2YWx1ZTogY29tcG9uZW50W25hbWVdXG4gICAgICAgIH0pKEFjY2Vzc29yU3ViY2xhc3MucHJvdG90eXBlLCBuYW1lKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICBjb25zdCBTdWJjbGFzcyA9IHN1YmNsYXNzKGNvbXBvbmVudC5lbC50YWdOYW1lKShBY2Nlc3NvclN1YmNsYXNzKTtcbiAgICBjb25zdCBhY2Nlc3NvciA9IG5ldyBTdWJjbGFzcygpO1xuICB9O1xufVxudmFyIGRlZmF1bHRHZXR0ZXJTZXR0ZXIgPSAodmFsdWUpID0+IHZhbHVlO1xuXG4vLyBzcmMvQ29udHJvbGxlck1hbmFnZXIudHNcbnZhciB1c2VDb250cm9sbGVyTWFuYWdlciA9IChjb21wb25lbnQpID0+IG5ldyBDb250cm9sbGVyTWFuYWdlcihjb21wb25lbnQpO1xudmFyIENvbnRyb2xsZXJNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBHZW5lcmljQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGNvbXBvbmVudCkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBjb250cm9sbGVySG9zdCA9IHtcbiAgICAgIGFkZENvbnRyb2xsZXI6IChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXJzLmFkZChjb250cm9sbGVyKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVDb250cm9sbGVyOiAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICBjb250cm9sbGVycy5kZWxldGUoY29udHJvbGxlcik7XG4gICAgICB9LFxuICAgICAgcmVxdWVzdFVwZGF0ZTogKCkgPT4gZm9yY2VVcGRhdGUoY29tcG9uZW50KVxuICAgIH07XG4gICAgZXh0ZW5kT2JqZWN0KGNvbXBvbmVudCwgY29udHJvbGxlckhvc3QpO1xuICAgIHN1cGVyKGNvbXBvbmVudCk7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgdGhpcy5pbnRlcm5hbHMgPSBuZXcgQ29tcG9uZW50SW50ZXJuYWxzKHRoaXMuY29tcG9uZW50KTtcbiAgICB0aGlzLmNvbm5lY3RlZCA9IHRoaXMuX2Nvbm5lY3RlZC5wcm9taXNlO1xuICAgIHRoaXMuaGFzRGVzdHJveSA9IGZhbHNlO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fdXBkYXRlUHJvbWlzZSA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIHRoaXMuX29yaWdpbmFsTGlmZWN5Y2xlcyA9IHt9O1xuICAgIC8qKlxuICAgICAqIEEgbWFnaWNhbCBzb2x1dGlvbiB0byBmaW5kaW5nIG91dCB3aGF0IHByb3BlcnR5IG5hbWUgYSBnaXZlbiBjb250cm9sbGVyXG4gICAgICogb24gYSBnaXZlbiBvYmplY3Qgd2FzIGFzc2lnbmVkIHRvLiBOb3RlLCB0aGlzIGRvZXMgbm90IHdvcmsgZm9yIHByb3BlcnRpZXNcbiAgICAgKiB0aGF0IGhhdmUgXFxAUHJvcCgpIG9yIFxcQFN0YXRlKCkgZGVjb3JhdG9yIC0gZm9yIHRob3NlLCB1c2VcbiAgICAgKiBtYW5hZ2VyLnRyYWNrUHJvcEtleSgpIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGZ1bmN0aW9uIHRyYWNrTWU8VD4oZGVmYXVsdFZhbHVlOlQsIGNvbXBvbmVudDpCYXNlQ29tcG9uZW50KTpUIHtcbiAgICAgKiAgIGNvbXBvbmVudC5tYW5hZ2VyLnRyYWNrUHJvcGVydHlLZXkoY29tcG9uZW50LCAoa2V5KT0+Y29uc29sZS5sb2coa2V5KSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgKiAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogY2xhc3MgTXlDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICAgKiAgIC8vIFdpbGwgY29uc29sZSBsb2cgXCJteVByb3BcIlxuICAgICAqICAgbXlQcm9wID0gdHJhY2tNZSgnYScsIHRoaXMpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMudHJhY2tQcm9wZXJ0eUtleSA9IHRyYWNrUHJvcGVydHlLZXk7XG4gICAgLyoqXG4gICAgICogTGlrZSBtYW5hZ2VyLnRyYWNrUHJvcGVydHlLZXkoKSwgYnV0IGZvciBwcm9wcyB0aGF0IGhhdmUgXFxAU3RhdGUoKSBvciBcXEBQcm9wKClcbiAgICAgKiBkZWNvcmF0b3JcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogZnVuY3Rpb24gdHJhY2tNZShjb21wb25lbnQ6QmFzZUNvbXBvbmVudCkge1xuICAgICAqICAgY29tcG9uZW50Lm1hbmFnZXIudHJhY2tQcm9wS2V5KChrZXkpPT5jb25zb2xlLmxvZyhrZXkpKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgICAqICAgLy8gV2lsbCBjb25zb2xlIGxvZyBcIm15UHJvcFwiXG4gICAgICogICBAUHJvcCgpIG15UHJvcCA9IHRyYWNrTWUodGhpcyk7XG4gICAgICpcbiAgICAgKiAgIC8vIFdpbGwgY29uc29sZSBsb2cgXCJteVN0YXRlXCJcbiAgICAgKiAgIEBTdGF0ZSgpIG15U3RhdGUgPSB0cmFja01lKHRoaXMpO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrUHJvcEtleSA9IHRoaXMuaW50ZXJuYWxzLnRyYWNrUHJvcEtleTtcbiAgICAvKipcbiAgICAgKiBBIGNvbWJpbmF0aW9uIG9mIHRyYWNrUHJvcGVydHlLZXkoKSBhbmQgdHJhY2tQcm9wS2V5KCkuIEZvciB1c2FnZSB3aGVuXG4gICAgICogeW91IHdhbnQgdG8gdHJhY2sgYSBwcm9wZXJ0eSwgYnV0IGRvbid0IGtub3cgaWYgaXQgd2lsbCBiZSBkZWZpbmVkIHdpdGggdGhlXG4gICAgICogXFxAUHJvcCgpIGRlY29yYXRvciBvciBub3RcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrS2V5ID0gdGhpcy5pbnRlcm5hbHMudHJhY2tLZXk7XG4gICAgdGhpcy5fcmVhZG9ubHlTZXR0ZXIgPSAobmV3VmFsdWUsIF9vbGRWYWx1ZSwgcHJvcGVydHkpID0+IHtcbiAgICAgIGlmIChDb250cm9sbGVyLmludGVybmFscy5zaG91bGRCeXBhc3NSZWFkb25seSlcbiAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgICAgY29uc3QgaXNQcm9wID0gZ2V0UHJvcFR5cGUodGhpcy5jb21wb25lbnQsIHByb3BlcnR5KSA9PT0gXCJwcm9wXCI7XG4gICAgICBpZiAoaXNQcm9wKVxuICAgICAgICBmb3JjZVVwZGF0ZSh0aGlzLmNvbXBvbmVudCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgYXNzaWduIHRvIHJlYWQtb25seSBwcm9wZXJ0eSBcIiR7cHJvcGVydHl9XCIgb2YgJHt0aGlzLmNvbXBvbmVudC5lbC50YWdOYW1lLnRvTG93ZXJDYXNlKCl9LiBUcnlpbmcgdG8gYXNzaWduIFwiJHtTdHJpbmcoXG4gICAgICAgICAgbmV3VmFsdWVcbiAgICAgICAgKX1cImBcbiAgICAgICk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbiBkZXZlbG9wbWVudCwgb24gaG90IG1vZHVsZSByZWxvYWQsIGNvbnRyb2xsZXIgd291bGQgYmUgcmUtaW5pdGlhbGl6ZWRcbiAgICAgKiB3aXRoIGFsbCBQcm9wcyBhbmQgU3RhdGUgdmFsdWVzIHBlcnNpc3RlbnQsIGJ1dCBwcm9wZXJ0aWVzIGxvc3QuIFRoaXMgdW5zYWZlXG4gICAgICogZGV2ZWxvcG1lbnQtb25seSBBUEkgbGV0cyB5b3Ugc2V0IG9yIGdldCBkYXRhIGZvciBhIGNvbnRyb2xsZXIgdGhhdCB3b3VsZFxuICAgICAqIHBlcnNpc3QgYWNyb3NzIGhvdCByZWxvYWRzLlxuICAgICAqL1xuICAgIHRoaXMuZGV2T25seVNldFBlcnNpc3RlbnRDb250cm9sbGVyRGF0YSA9IHZvaWQgMCA7XG4gICAgdGhpcy5kZXZPbmx5R2V0UGVyc2lzdGVudENvbnRyb2xsZXJEYXRhID0gdm9pZCAwIDtcbiAgICB0aGlzLmNvbXBvbmVudC5tYW5hZ2VyID0gdGhpcztcbiAgICByZXRyaWV2ZUNvbXBvbmVudE1ldGEoY29tcG9uZW50KTtcbiAgICB0aGlzLl9jb250cm9sbGVycyA9IGNvbnRyb2xsZXJzO1xuICAgIHRoaXMuZXhwb3J0cyA9IHZvaWQgMDtcbiAgICB0aGlzLmhhc0Rlc3Ryb3kgPSBcInByZXNlcnZlT25EaXNjb25uZWN0XCIgaW4gdGhpcy5jb21wb25lbnQgJiYgdHlwZW9mIHRoaXMuY29tcG9uZW50LmRlc3Ryb3kgPT09IFwiZnVuY3Rpb25cIjtcbiAgICBpZiAodGhpcy5oYXNEZXN0cm95KVxuICAgICAgdGhpcy53YXRjaChcInByZXNlcnZlT25EaXNjb25uZWN0XCIsICgpID0+IHRoaXMuX3ByZXNlcnZlT25EaXNjb25uZWN0V2F0Y2hlcigpKTtcbiAgICB0aGlzLl9iaW5kTGlmZWN5Y2xlTWV0aG9kcygpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb21wb25lbnQsIFwidXBkYXRlQ29tcGxldGVcIiwge1xuICAgICAgZ2V0OiBhc3luYyAoKSA9PiBhd2FpdCB0aGlzLl91cGRhdGVQcm9taXNlLnByb21pc2VcbiAgICB9KTtcbiAgICB0aGlzLmludGVybmFscy5yZWFjdGl2ZVV0aWxzSW50ZWdyYXRpb24gPSByZWFjdGl2ZVV0aWxzSW50ZWdyYXRpb24odGhpcy5jb21wb25lbnQpO1xuICAgIENvbnRyb2xsZXIuaW50ZXJuYWxzLnNldFBhcmVudENvbnRyb2xsZXIodm9pZCAwKTtcbiAgICBDb250cm9sbGVyLmludGVybmFscy5zZXRBbWJpZW50Q29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgQ29udHJvbGxlci5pbnRlcm5hbHMuZWxlbWVudFRvSW5zdGFuY2Uuc2V0KGNvbXBvbmVudC5lbCwgY29tcG9uZW50KTtcbiAgICBDb250cm9sbGVyLmludGVybmFscy5lbGVtZW50VG9JbnN0YW5jZS5zZXQoY29tcG9uZW50LCBjb21wb25lbnQpO1xuICB9XG4gIF9iaW5kTGlmZWN5Y2xlTWV0aG9kcygpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcbiAgICB0aGlzLl9vcmlnaW5hbExpZmVjeWNsZXMgPSB7XG4gICAgICBjb25uZWN0ZWRDYWxsYmFjazogY29tcG9uZW50LmNvbm5lY3RlZENhbGxiYWNrLFxuICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2s6IGNvbXBvbmVudC5kaXNjb25uZWN0ZWRDYWxsYmFjayxcbiAgICAgIGNvbXBvbmVudFdpbGxMb2FkOiBjb21wb25lbnQuY29tcG9uZW50V2lsbExvYWQsXG4gICAgICBjb21wb25lbnREaWRMb2FkOiBjb21wb25lbnQuY29tcG9uZW50RGlkTG9hZCxcbiAgICAgIGNvbXBvbmVudFdpbGxSZW5kZXI6IGNvbXBvbmVudC5jb21wb25lbnRXaWxsUmVuZGVyLFxuICAgICAgY29tcG9uZW50RGlkUmVuZGVyOiBjb21wb25lbnQuY29tcG9uZW50RGlkUmVuZGVyLFxuICAgICAgY29tcG9uZW50V2lsbFVwZGF0ZTogY29tcG9uZW50LmNvbXBvbmVudFdpbGxVcGRhdGUsXG4gICAgICBjb21wb25lbnREaWRVcGRhdGU6IGNvbXBvbmVudC5jb21wb25lbnREaWRVcGRhdGUsXG4gICAgICBkZXN0cm95OiBjb21wb25lbnQuZGVzdHJveVxuICAgIH07XG4gICAgY29tcG9uZW50LmNvbm5lY3RlZENhbGxiYWNrID0gdGhpcy5fY29ubmVjdGVkQ2FsbGJhY2suYmluZCh0aGlzKTtcbiAgICBjb21wb25lbnQuZGlzY29ubmVjdGVkQ2FsbGJhY2sgPSB0aGlzLl9kaXNjb25uZWN0ZWRDYWxsYmFjay5iaW5kKHRoaXMpO1xuICAgIGNvbXBvbmVudC5jb21wb25lbnRXaWxsTG9hZCA9IHRoaXMuX2NvbXBvbmVudFdpbGxMb2FkLmJpbmQodGhpcyk7XG4gICAgY29tcG9uZW50LmNvbXBvbmVudERpZExvYWQgPSB0aGlzLl9jb21wb25lbnREaWRMb2FkLmJpbmQodGhpcyk7XG4gICAgY29tcG9uZW50LmNvbXBvbmVudFdpbGxSZW5kZXIgPSB0aGlzLl9jb21wb25lbnRXaWxsUmVuZGVyLmJpbmQodGhpcyk7XG4gICAgY29tcG9uZW50LmNvbXBvbmVudERpZFJlbmRlciA9IHRoaXMuX2NvbXBvbmVudERpZFJlbmRlci5iaW5kKHRoaXMpO1xuICAgIGNvbXBvbmVudC5jb21wb25lbnRXaWxsVXBkYXRlID0gdGhpcy5fY29tcG9uZW50V2lsbFVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgIGNvbXBvbmVudC5jb21wb25lbnREaWRVcGRhdGUgPSB0aGlzLl9jb21wb25lbnREaWRVcGRhdGUuYmluZCh0aGlzKTtcbiAgICBpZiAodGhpcy5oYXNEZXN0cm95KVxuICAgICAgY29tcG9uZW50LmRlc3Ryb3kgPSB0aGlzLmRlc3Ryb3kuYmluZCh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogVGhyb3dzIGFuIGVycm9yIGlmIGNvbXBvbmVudCBkb2VzIG5vdCBpbXBsZW1lbnQgZGVzdHJveSgpIGxpZmVjeWNsZSwgYnV0XG4gICAqIHRyaWVzIHRvIHVzZSBpdC5cbiAgICovXG4gIGVuc3VyZUhhc0Rlc3Ryb3koKSB7XG4gICAgaWYgKCF0aGlzLmhhc0Rlc3Ryb3kpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZGVzdHJveUVycm9yTWVzc2FnZSk7XG4gIH1cbiAgLyoqXG4gICAqIFByaXZhdGUgYmVjYXVzZSB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBiZSBjYWxsZWQgYnkgQ29tcG9uZW50IGRpcmVjdGx5LlxuICAgKiBJbnN0ZWFkLCBfYmluZExpZmVjeWNsZU1ldGhvZHMgd2lsbCB0YWtlIGNhcmUgb2YgdGhhdC4gT3RoZXJ3aXNlLCB5b3Ugcmlza1xuICAgKiBjYWxsaW5nIGxpZmVjeWNsZSBtZXRob2RzIHR3aWNlLlxuICAgKi9cbiAgX2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgY29uc3QgdGFnTmFtZSA9IHRoaXMuY29tcG9uZW50LmVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRoaXMuY29tcG9uZW50LmVsLnJlbW92ZSgpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlICR7dGFnTmFtZX0gY29tcG9uZW50IGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkLiBJdCBjYW4gbm90IGJlIHVzZWQgYWdhaW4uIElmIHlvdSBtZWFudCB0byBkaXNjb25uZWN0IGFuZCByZWNvbm5lY3QgYSBjb21wb25lbnQgd2l0aG91dCBhdXRvbWF0aWMgZGVzdHJveSwgc2V0IHRoZSBwcmVzZXJ2ZU9uRGlzY29ubmVjdCBwcm9wLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuaW50ZXJuYWxzLmVuYWJsZWRXYXRjaGVycyA9IHRoaXMuaW50ZXJuYWxzLmFsbFdhdGNoZXJzO1xuICAgIGtleVRyYWNrUmVzb2x2ZSgpO1xuICAgIHRoaXMuX2Nvbm5lY3RlZC5yZXNvbHZlKCk7XG4gICAgdGhpcy5fY29udHJvbGxlcnMuZm9yRWFjaChcbiAgICAgIChjb250cm9sbGVyKSA9PiBcInRyaWdnZXJDb25uZWN0ZWRcIiBpbiBjb250cm9sbGVyID8gY29udHJvbGxlci50cmlnZ2VyQ29ubmVjdGVkKCkgOiBzYWZlQ2FsbCgoKSA9PiBjb250cm9sbGVyLmhvc3RDb25uZWN0ZWQ/LigpKVxuICAgICk7XG4gICAgdGhpcy5fb3JpZ2luYWxMaWZlY3ljbGVzLmNvbm5lY3RlZENhbGxiYWNrPy5jYWxsKHRoaXMuY29tcG9uZW50KTtcbiAgfVxuICBfZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2NvbnRyb2xsZXJzLmZvckVhY2goXG4gICAgICAoY29udHJvbGxlcikgPT4gXCJ0cmlnZ2VyRGlzY29ubmVjdGVkXCIgaW4gY29udHJvbGxlciA/IGNvbnRyb2xsZXIudHJpZ2dlckRpc2Nvbm5lY3RlZCgpIDogc2FmZUNhbGwoKCkgPT4gY29udHJvbGxlci5ob3N0RGlzY29ubmVjdGVkPy4oKSlcbiAgICApO1xuICAgIHRoaXMuX29yaWdpbmFsTGlmZWN5Y2xlcy5kaXNjb25uZWN0ZWRDYWxsYmFjaz8uY2FsbCh0aGlzLmNvbXBvbmVudCk7XG4gICAgaWYgKHRoaXMuaGFzRGVzdHJveSlcbiAgICAgIHRoaXMuX3ByZXNlcnZlT25EaXNjb25uZWN0V2F0Y2hlcigpO1xuICB9XG4gIGFzeW5jIF9jb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICBhd2FpdCB0aGlzLmludGVybmFscy5yZWFjdGl2ZVV0aWxzSW50ZWdyYXRpb24oKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoXG4gICAgICBBcnJheS5mcm9tKFxuICAgICAgICB0aGlzLl9jb250cm9sbGVycyxcbiAgICAgICAgYXN5bmMgKGNvbnRyb2xsZXIpID0+IFwidHJpZ2dlckxvYWRcIiBpbiBjb250cm9sbGVyID8gYXdhaXQgY29udHJvbGxlci50cmlnZ2VyTG9hZCgpIDogYXdhaXQgc2FmZUFzeW5jQ2FsbChhc3luYyAoKSA9PiBhd2FpdCBjb250cm9sbGVyLmhvc3RMb2FkPy4oKSlcbiAgICAgIClcbiAgICApO1xuICAgIGF3YWl0IHRoaXMuX29yaWdpbmFsTGlmZWN5Y2xlcy5jb21wb25lbnRXaWxsTG9hZD8uY2FsbCh0aGlzLmNvbXBvbmVudCk7XG4gIH1cbiAgX2NvbXBvbmVudERpZExvYWQoKSB7XG4gICAgdGhpcy5fY29udHJvbGxlcnMuZm9yRWFjaChcbiAgICAgIChjb250cm9sbGVyKSA9PiBcInRyaWdnZXJMb2FkZWRcIiBpbiBjb250cm9sbGVyID8gY29udHJvbGxlci50cmlnZ2VyTG9hZGVkKCkgOiBzYWZlQ2FsbCgoKSA9PiBjb250cm9sbGVyLmhvc3RMb2FkZWQ/LigpKVxuICAgICk7XG4gICAgdGhpcy5fb3JpZ2luYWxMaWZlY3ljbGVzLmNvbXBvbmVudERpZExvYWQ/LmNhbGwodGhpcy5jb21wb25lbnQpO1xuICB9XG4gIGFzeW5jIF9jb21wb25lbnRXaWxsUmVuZGVyKCkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChcbiAgICAgIEFycmF5LmZyb20oXG4gICAgICAgIHRoaXMuX2NvbnRyb2xsZXJzLFxuICAgICAgICBhc3luYyAoY29udHJvbGxlcikgPT4gXCJ0cmlnZ2VyUmVuZGVyXCIgaW4gY29udHJvbGxlciA/IGF3YWl0IGNvbnRyb2xsZXIudHJpZ2dlclJlbmRlcigpIDogYXdhaXQgc2FmZUFzeW5jQ2FsbChhc3luYyAoKSA9PiBhd2FpdCBjb250cm9sbGVyLmhvc3RSZW5kZXI/LigpKVxuICAgICAgKVxuICAgICk7XG4gICAgYXdhaXQgdGhpcy5fb3JpZ2luYWxMaWZlY3ljbGVzLmNvbXBvbmVudFdpbGxSZW5kZXI/LmNhbGwodGhpcy5jb21wb25lbnQpO1xuICB9XG4gIF9jb21wb25lbnREaWRSZW5kZXIoKSB7XG4gICAgdGhpcy5fY29udHJvbGxlcnMuZm9yRWFjaChcbiAgICAgIChjb250cm9sbGVyKSA9PiBcInRyaWdnZXJSZW5kZXJlZFwiIGluIGNvbnRyb2xsZXIgPyBjb250cm9sbGVyLnRyaWdnZXJSZW5kZXJlZCgpIDogc2FmZUNhbGwoKCkgPT4gY29udHJvbGxlci5ob3N0UmVuZGVyZWQ/LigpKVxuICAgICk7XG4gICAgdGhpcy5fb3JpZ2luYWxMaWZlY3ljbGVzLmNvbXBvbmVudERpZFJlbmRlcj8uY2FsbCh0aGlzLmNvbXBvbmVudCk7XG4gIH1cbiAgYXN5bmMgX2NvbXBvbmVudFdpbGxVcGRhdGUoKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFxuICAgICAgQXJyYXkuZnJvbShcbiAgICAgICAgdGhpcy5fY29udHJvbGxlcnMsXG4gICAgICAgIGFzeW5jIChjb250cm9sbGVyKSA9PiBcInRyaWdnZXJVcGRhdGVcIiBpbiBjb250cm9sbGVyID8gYXdhaXQgY29udHJvbGxlci50cmlnZ2VyVXBkYXRlKCkgOiBhd2FpdCBzYWZlQXN5bmNDYWxsKGFzeW5jICgpID0+IGF3YWl0IGNvbnRyb2xsZXIuaG9zdFVwZGF0ZT8uKCkpXG4gICAgICApXG4gICAgKTtcbiAgICBhd2FpdCB0aGlzLl9vcmlnaW5hbExpZmVjeWNsZXMuY29tcG9uZW50V2lsbFVwZGF0ZT8uY2FsbCh0aGlzLmNvbXBvbmVudCk7XG4gIH1cbiAgX2NvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB0aGlzLl9jb250cm9sbGVycy5mb3JFYWNoKFxuICAgICAgKGNvbnRyb2xsZXIpID0+IFwidHJpZ2dlclVwZGF0ZWRcIiBpbiBjb250cm9sbGVyID8gY29udHJvbGxlci50cmlnZ2VyVXBkYXRlZCgpIDogc2FmZUNhbGwoKCkgPT4gY29udHJvbGxlci5ob3N0VXBkYXRlZD8uKCkpXG4gICAgKTtcbiAgICB0aGlzLl9vcmlnaW5hbExpZmVjeWNsZXMuY29tcG9uZW50RGlkVXBkYXRlPy5jYWxsKHRoaXMuY29tcG9uZW50KTtcbiAgICBjb25zdCB1cGRhdGVQcm9taXNlID0gdGhpcy5fdXBkYXRlUHJvbWlzZTtcbiAgICB0aGlzLl91cGRhdGVQcm9taXNlID0gbmV3IERlZmVycmVkKCk7XG4gICAgdXBkYXRlUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICB9XG4gIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5lbnN1cmVIYXNEZXN0cm95KCk7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLmNvbXBvbmVudC5lbC5pc0Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy5oYXNEZXN0cm95ID0gZmFsc2U7XG4gICAgICB0aGlzLmNvbXBvbmVudC5lbC5yZW1vdmUoKTtcbiAgICAgIHRoaXMuaGFzRGVzdHJveSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLl9jb250cm9sbGVycy5mb3JFYWNoKFxuICAgICAgKGNvbnRyb2xsZXIpID0+IFwidHJpZ2dlckRlc3Ryb3lcIiBpbiBjb250cm9sbGVyID8gY29udHJvbGxlci50cmlnZ2VyRGVzdHJveSgpIDogc2FmZUNhbGwoKCkgPT4gY29udHJvbGxlci5ob3N0RGVzdHJveT8uKCkpXG4gICAgKTtcbiAgICBhd2FpdCB0aGlzLl9vcmlnaW5hbExpZmVjeWNsZXMuZGVzdHJveT8uY2FsbCh0aGlzLmNvbXBvbmVudCk7XG4gIH1cbiAgX3ByZXNlcnZlT25EaXNjb25uZWN0V2F0Y2hlcigpIHtcbiAgICBpZiAoIXRoaXMuY29tcG9uZW50LmVsLmlzQ29ubmVjdGVkICYmICF0aGlzLmNvbXBvbmVudC5wcmVzZXJ2ZU9uRGlzY29ubmVjdClcbiAgICAgIHZvaWQgdGhpcy5kZXN0cm95KCkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2UgYSBAUHJvcCgpIG9yIEBTdGF0ZSgpIHJlYWRvbmx5IChwcmV2ZW50IG92ZXJ3cml0aW5nIGRlZmF1bHQgdmFsdWUpLlxuICAgKlxuICAgKiBGb3IgaW50ZXJuYWwgcHJvcGVydGllcywgcHJlZmVyIFR5cGVTY3JpcHQncyBcInJlYWRvbmx5XCIgbW9kaWZpZXIgaW5zdGVhZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gRGVmaW5pbmcgcmVhZG9ubHkgcHJvcFxuICAgKiBAUHJvcCh7IHJlZmxlY3Q6IHRydWUgfSkgcHJvcCA9IHRoaXMubWFuYWdlci5yZWFkb25seSgnYScpO1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBPdmVyd3JpdGluZyByZWFkb25seSBwcm9wIGludGVybmFsbHlcbiAgICogdGhpcy5tYW5hZ2VyLmJ5cGFzc1JlYWRvbmx5KCgpPT57XG4gICAqICAgdGhpcy5wcm9wID0gJ2InO1xuICAgKiB9KTtcbiAgICpcbiAgICovXG4gIHJlYWRvbmx5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2V0KHZhbHVlLCB7IHNldDogdGhpcy5fcmVhZG9ubHlTZXR0ZXIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIExpc3RlbiBmb3IgYW55IGNvbXBvbmVudCdzIEBTdGF0ZSgpL0BQcm9wKCkgY2hhbmdlLCBhbmQgbXV0YXRlIGl0J3NcbiAgICogdmFsdWUgYmVmb3JlIGl0IGlzIHNldC5cbiAgICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBTdGVuY2lsJ3MgQ29tcGlsZXIgZG9lcyBub3Qgc3VwcG9ydCBnZXQvc2V0IGZvclxuICAgKiBAU3RhdGUoKS9AUHJvcCgpLlxuICAgKiBGb3IgcHJpdmF0ZSBjb21wb25lbnQgcHJvcGVydGllcywgeW91IHNob3VsZCB1c2UgcmVndWxhciBnZXQvc2V0IHN5bnRheC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogQFByb3AoKSBleGFtcGxlUHJvcCA9IHRoaXMubWFuYWdlci5nZXRTZXQoZGVmYXVsdFZhbHVlLHtnZXQsc2V0fSlcbiAgICogQFByb3AoKSBzb21lUHJvcCA9IHRoaXMubWFuYWdlci5nZXRTZXQoXG4gICAqICAgdW5kZWZpbmVkIGFzIHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICogICB7XG4gICAqICAgICBnZXQ6ICh2YWx1ZSk9PnZhbHVlLnRyaW0oKSxcbiAgICogICAgIHNldDogKG5ld1ZhbHVlLG9sZFZhbHVlKSA9PiBuZXdWYWx1ZS50cmltKCkgPz8gb2xkVmFsdWVcbiAgICogICB9XG4gICAqIClcbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVW5saWtlIGEgbmF0aXZlIGdldC9zZXQsIHRoZSBnZXQgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIGN1cnJlbnQgYXR0cmlidXRlXG4gICAqIHZhbHVlLCBhbmQgY2FuIG1vZGlmeSBpdCBiZWZvcmUgcmV0dXJuaW5nIGl0IChvciBjYW4gZGlzcmVnYXJkIHRoZSBjdXJyZW50XG4gICAqIHZhbHVlIGFuZCBnZXQgaXQgZnJvbSBlbHNld2hlcmUgaW5zdGVhZCkuXG4gICAqIFNpbWlsYXJseSwgc2V0dGVyIGlzIGNhbGxlZCB3aXRoIHRoZSBuZXcgYW5kIG9sZCB2YWx1ZSwgYW5kIGlzIGV4cGVjdGVkIHRvXG4gICAqIHJldHVybiB0aGUgZmluYWwgbmV3IHZhbHVlIChvciByZXR1cm4gdGhlIG9sZCB2YWx1ZSB0byB1bmRvIHRoZSBjaGFuZ2UpXG4gICAqL1xuICBnZXRTZXQoZGVmYXVsdFZhbHVlLCBnZXRTZXQpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnQubWFuYWdlci50cmFja1Byb3BLZXkoKG5hbWUpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJVbmFibGUgdG8gcmVzb2x2ZSBnZXQvc2V0J3MgcHJvcCBuYW1lLiBNYWtlIHN1cmUgeW91IGFyZSB1c2luZyBpdCBsaWtlIEBQcm9wKCkgc29tZVByb3AgPSB0aGlzLm1hbmFnZXIuZ2V0U2V0KGRlZmF1bHRWYWx1ZSx7Z2V0LHNldH0pXCJcbiAgICAgICAgKTtcbiAgICAgIGlmIChnZXRTZXQuc2V0ID09PSB0aGlzLl9yZWFkb25seVNldHRlcikge1xuICAgICAgICAoX2EyID0gdGhpcy5pbnRlcm5hbHMpLnJlYWRvbmx5UHJvcHMgPz8gKF9hMi5yZWFkb25seVByb3BzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxzLnJlYWRvbmx5UHJvcHMuYWRkKG5hbWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgZ2VuZXJpY0NvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgY29uc3QgdmFsdWUgPSBnZW5lcmljQ29tcG9uZW50W25hbWVdO1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGRlZmF1bHRWYWx1ZSAmJiB0eXBlb2YgZ2V0U2V0LnNldCA9PT0gXCJmdW5jdGlvblwiICYmIGdldFNldC5pbml0aWFsU2V0ICE9PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGdldFNldC5zZXQodmFsdWUsIGRlZmF1bHRWYWx1ZSwgbmFtZSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gdmFsdWUpXG4gICAgICAgICAgZ2VuZXJpY0NvbXBvbmVudFtuYW1lXSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgICAgdGhpcy5nZW5lcmljR2V0U2V0KG5hbWUsIGdldFNldCk7XG4gICAgfSwgZGVmYXVsdFZhbHVlKTtcbiAgfVxufTtcbnZhciBkZXN0cm95RXJyb3JNZXNzYWdlID0gYFxuSWYgdGhlIGNvbXBvbmVudCB1c2VzIGEgY29udHJvbGxlciB0aGF0IHVzZXMgZGVzdHJveSgpIG1ldGhvZCwgdGhlbiB0aGVcbmNvbXBvbmVudCBtdXN0IGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuJHsvLyBEb24ndCBleHBvc2UgaW50ZXJuYWwgY29kZSBpbiBwcm9kdWN0aW9uLCBhbmQga2VlcCBidW5kbGUgc21hbGxlcjpcbmBwcmVzZXJ2ZU9uRGlzY29ubmVjdCBhbmQgZGVzdHJveWAgfVxuYC50cmltKCk7XG5cbi8vIHNyYy9wcm94eUV4cG9ydHMudHNcbnZhciBwcm94eUV4cG9ydHMgPSAoQ2xhc3MpID0+ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGFtYmllbnRDb250cm9sbGVycyA9IENvbnRyb2xsZXIuaW50ZXJuYWxzLnJldHJpZXZlUGFyZW50Q29udHJvbGxlcnMoKTtcbiAgY29uc3QgaW5zdGFuY2UgPSBuZXcgQ2xhc3MoLi4uYXJncyk7XG4gIGNvbnN0IGluaXRpYWxFeHBvcnRzID0gaW5zdGFuY2UuZXhwb3J0cztcbiAgQ29udHJvbGxlci5pbnRlcm5hbHMuc2V0UGFyZW50Q29udHJvbGxlcihhbWJpZW50Q29udHJvbGxlcnMuYXQoLTEpKTtcbiAgY29uc3QgaW50ZXJuYWxzID0gaW5zdGFuY2UuY29tcG9uZW50Lm1hbmFnZXIuaW50ZXJuYWxzO1xuICBpbnRlcm5hbHMubWFya0V4cG9ydHMoaW5zdGFuY2UsIGluaXRpYWxFeHBvcnRzKTtcbiAgaW5zdGFuY2Uud2F0Y2hFeHBvcnRzKChleHBvcnRzKSA9PiBpbnRlcm5hbHMubWFya0V4cG9ydHMoaW5zdGFuY2UsIGV4cG9ydHMpKTtcbiAgQ29udHJvbGxlci5pbnRlcm5hbHMuc2V0QW1iaWVudENoaWxkQ29udHJvbGxlcihpbnN0YW5jZSk7XG4gIGNvbnN0IGhvc3RDYW5kaWRhdGVzID0gW2luc3RhbmNlLmNvbXBvbmVudCwgLi4uYW1iaWVudENvbnRyb2xsZXJzXS5yZXZlcnNlKCk7XG4gIHJldHVybiBpbnRlcm5hbHMudHJhY2tLZXkoXG4gICAgaG9zdENhbmRpZGF0ZXMsXG4gICAgKHJlc29sdXRpb24pID0+IHJlc29sdXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNldFByb3h5KGluc3RhbmNlLCByZXNvbHV0aW9uLmhvc3QsIHJlc29sdXRpb24ua2V5LCBpbml0aWFsRXhwb3J0cyksXG4gICAgaW5pdGlhbEV4cG9ydHNcbiAgKTtcbn07XG5mdW5jdGlvbiBzZXRQcm94eShjb250cm9sbGVyLCBob3N0LCBrZXksIGluaXRpYWxFeHBvcnRzKSB7XG4gIGNvbnN0IGdlbmVyaWNIb3N0ID0gaG9zdDtcbiAgY29uc3QgY29udHJvbGxlclZhbHVlQ2hhbmdlZCA9IGdlbmVyaWNIb3N0W2tleV0gIT09IGNvbnRyb2xsZXIuZXhwb3J0cztcbiAgY29uc3QgaG9zdFZhbHVlQ2hhbmdlZCA9IGdlbmVyaWNIb3N0W2tleV0gIT09IGluaXRpYWxFeHBvcnRzO1xuICBjb25zdCBjb250cm9sbGVyVXBkYXRlZEV4cG9ydHMgPSBpbml0aWFsRXhwb3J0cyAhPT0gY29udHJvbGxlci5leHBvcnRzO1xuICBpZiAoY29udHJvbGxlclZhbHVlQ2hhbmdlZCAmJiAhaG9zdFZhbHVlQ2hhbmdlZCAmJiBjb250cm9sbGVyVXBkYXRlZEV4cG9ydHMpXG4gICAgZ2VuZXJpY0hvc3Rba2V5XSA9IGNvbnRyb2xsZXIuZXhwb3J0cztcbiAgY29udHJvbGxlci53YXRjaEV4cG9ydHMoKCkgPT4ge1xuICAgIGlmIChnZW5lcmljSG9zdFtrZXldID09PSBjb250cm9sbGVyLmV4cG9ydHMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbWFuYWdlciA9IGNvbnRyb2xsZXIuY29tcG9uZW50Lm1hbmFnZXI7XG4gICAgY29uc3QgaXNSZWFkT25seSA9IG1hbmFnZXIuaW50ZXJuYWxzLnJlYWRvbmx5UHJvcHM/LmhhcyhrZXkpID09PSB0cnVlO1xuICAgIGlmIChpc1JlYWRPbmx5KVxuICAgICAgbWFuYWdlci5ieXBhc3NSZWFkb25seSgoKSA9PiB7XG4gICAgICAgIGdlbmVyaWNIb3N0W2tleV0gPSBjb250cm9sbGVyLmV4cG9ydHM7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBnZW5lcmljSG9zdFtrZXldID0gY29udHJvbGxlci5leHBvcnRzO1xuICB9KTtcbn1cblxuLy8gc3JjL2Z1bmN0aW9uYWwudHNcbnZhciBtYWtlQ29udHJvbGxlciA9IChjb25zdHJ1Y3RvcikgPT4gcHJveHkodm9pZCAwLCBjb25zdHJ1Y3Rvcik7XG52YXIgRnVuY3Rpb25hbENvbnRyb2xsZXIgPSBjbGFzcyBleHRlbmRzIENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3Rvcihjb21wb25lbnQsIGNvbnN0cnVjdG9yKSB7XG4gICAgc3VwZXIoY29tcG9uZW50KTtcbiAgICBjb25zdCBvcmlnaW5hbEV4cG9ydHMgPSB0aGlzLmV4cG9ydHM7XG4gICAgdHJ5IHtcbiAgICAgIENvbnRyb2xsZXIuaW50ZXJuYWxzLnNldEFtYmllbnRDb21wb25lbnQodGhpcy5jb21wb25lbnQpO1xuICAgICAgY29uc3QgdmFsdWUgPSBjb25zdHJ1Y3Rvcih0aGlzLmNvbXBvbmVudCwgdGhpcyk7XG4gICAgICBjb25zdCBjb25zdHJ1Y3RvckNoYW5nZWRFeHBvcnRzID0gdGhpcy5leHBvcnRzICE9PSBvcmlnaW5hbEV4cG9ydHM7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIGlmICghY29uc3RydWN0b3JDaGFuZ2VkRXhwb3J0cylcbiAgICAgICAgICB0aGlzLnNldFByb3Zpc2lvbmFsRXhwb3J0cyh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gdmFsdWUudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgdGhpcy5leHBvcnRzID0gcmVzdWx0O1xuICAgICAgICAgIHN1cGVyLmNhdGNoVXBMaWZlY3ljbGUoKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgdGhpcy5fcmVhZHkucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Mb2FkKGFzeW5jICgpID0+IGF3YWl0IHJlc29sdmVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghY29uc3RydWN0b3JDaGFuZ2VkRXhwb3J0cyB8fCB2YWx1ZSAhPT0gdm9pZCAwKVxuICAgICAgICAgIHRoaXMuZXhwb3J0cyA9IHZhbHVlO1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBzdXBlci5jYXRjaFVwTGlmZWN5Y2xlKCkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLl9yZWFkeS5yZWplY3QoZXJyb3IpO1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG4gIC8qKiBOb29wIC0gd2lsbCBiZSBjYWxsZWQgaW4gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQgKi9cbiAgY2F0Y2hVcExpZmVjeWNsZSgpIHtcbiAgICByZXR1cm47XG4gIH1cbn07XG52YXIgcHJveHkgPSBwcm94eUV4cG9ydHMoRnVuY3Rpb25hbENvbnRyb2xsZXIpO1xuXG4vLyBzcmMvbG9hZC50c1xudmFyIGxvYWQgPSAobG9hZGVyKSA9PiBtYWtlQ29udHJvbGxlcihsb2FkZXIpO1xudmFyIEFjY2Vzc29yQ29udHJvbGxlciA9IGNsYXNzIGV4dGVuZHMgR2VuZXJpY0NvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3Rvcihjb21wb25lbnQsIF9sb2FkQWNjZXNzb3IpIHtcbiAgICBzdXBlcihjb21wb25lbnQpO1xuICAgIHRoaXMuX2xvYWRBY2Nlc3NvciA9IF9sb2FkQWNjZXNzb3I7XG4gICAgdGhpcy5yZWFjdGl2ZVV0aWxzID0gdGhpcy5jb21wb25lbnQucmVhY3RpdmVVdGlscztcbiAgICB0aGlzLl93YXRjaGVkUHJvcGVydGllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5zZXRQcm92aXNpb25hbEV4cG9ydHMoYWNjZXNzb3JJbnRlcm5hbHMubWFrZUdldHRlclByb3h5KGNvbXBvbmVudCwgdGhpcy5fd2F0Y2hlZFByb3BlcnRpZXMpKTtcbiAgICB0aGlzLl9vcmlnaW5hbFJlYWN0aXZlVXRpbHNJbnRlZ3JhdGlvbiA9IHRoaXMuY29tcG9uZW50Lm1hbmFnZXIuaW50ZXJuYWxzLnJlYWN0aXZlVXRpbHNJbnRlZ3JhdGlvbjtcbiAgICB0aGlzLmNvbXBvbmVudC5tYW5hZ2VyLmludGVybmFscy5yZWFjdGl2ZVV0aWxzSW50ZWdyYXRpb24gPSB0aGlzLmhvc3RMb2FkLmJpbmQodGhpcyk7XG4gIH1cbiAgYXN5bmMgaG9zdExvYWQoKSB7XG4gICAgdGhpcy5fbG9hZGluZ1Byb21pc2UgPz8gKHRoaXMuX2xvYWRpbmdQcm9taXNlID0gc2FmZUFzeW5jQ2FsbCh0aGlzLl9sb2FkLmJpbmQodGhpcykpKTtcbiAgICBhd2FpdCB0aGlzLl9sb2FkaW5nUHJvbWlzZTtcbiAgfVxuICBhc3luYyBfbG9hZCgpIHtcbiAgICBpZiAodGhpcy5jb21wb25lbnQucmVhY3RpdmVVdGlscyA9PT0gdm9pZCAwKVxuICAgICAgdGhpcy5yZWFjdGl2ZVV0aWxzID0gYXdhaXQgaW1wb3J0Q29yZVJlYWN0aXZlVXRpbHMoKTtcbiAgICBlbHNlXG4gICAgICB0aGlzLnJlYWN0aXZlVXRpbHMgPSBhd2FpdCB0aGlzLnVzZSh0aGlzLmNvbXBvbmVudC5yZWFjdGl2ZVV0aWxzKTtcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gYWNjZXNzb3JJbnRlcm5hbHMuZ2F0aGVyUGFyYW1ldGVycyh0aGlzLCB0aGlzLl93YXRjaGVkUHJvcGVydGllcyk7XG4gICAgdGhpcy5faW5zdGFuY2UgPSBhd2FpdCB0aGlzLl9jcmVhdGVJbnN0YW5jZShwYXJhbWV0ZXJzKTtcbiAgICBjb25zdCBtZW1iZXJzID0gZ2V0UHJvcExpa2VNZW1iZXJzKHRoaXMuY29tcG9uZW50KTtcbiAgICBjb25zdCB1bndhdGNoZWRNZW1iZXJzID0gbWVtYmVycy5maWx0ZXIoKG1lbWJlcikgPT4gIXRoaXMuX3dhdGNoZWRQcm9wZXJ0aWVzLmhhcyhtZW1iZXIpKTtcbiAgICBpZiAodW53YXRjaGVkTWVtYmVycy5sZW5ndGggPiAwKVxuICAgICAgYXdhaXQgdGhpcy5fb3JpZ2luYWxSZWFjdGl2ZVV0aWxzSW50ZWdyYXRpb24odW53YXRjaGVkTWVtYmVycyk7XG4gICAgYWNjZXNzb3JJbnRlcm5hbHMud2F0Y2hDb21wb25lbnRVcGRhdGVzKHRoaXMsIHRoaXMuX2luc3RhbmNlLCB0aGlzLl93YXRjaGVkUHJvcGVydGllcyk7XG4gICAgYWNjZXNzb3JJbnRlcm5hbHMud2F0Y2hBY2Nlc3NvclVwZGF0ZXModGhpcywgdGhpcy5faW5zdGFuY2UsIHRoaXMuX3dhdGNoZWRQcm9wZXJ0aWVzKTtcbiAgICB0aGlzLmV4cG9ydHMgPSB0aGlzLl9pbnN0YW5jZTtcbiAgfVxuICBhc3luYyBfY3JlYXRlSW5zdGFuY2UocGFyYW1ldGVycykge1xuICAgIGlmICh0aGlzLl9pc0FjY2Vzc29yQ29uc3RydWN0b3IodGhpcy5fbG9hZEFjY2Vzc29yKSlcbiAgICAgIHJldHVybiBuZXcgdGhpcy5fbG9hZEFjY2Vzc29yKHBhcmFtZXRlcnMpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9sb2FkQWNjZXNzb3IocGFyYW1ldGVycyk7XG4gIH1cbiAgX2lzQWNjZXNzb3JDb25zdHJ1Y3Rvcihsb2FkZXIpIHtcbiAgICByZXR1cm4gXCJwcm90b3R5cGVcIiBpbiBsb2FkZXIgJiYgXCJkZWNsYXJlZENsYXNzXCIgaW4gbG9hZGVyLnByb3RvdHlwZTtcbiAgfVxufTtcbnZhciBhY2Nlc3NvckludGVybmFscyA9IHtcbiAgbWFrZUdldHRlclByb3h5OiAoY29tcG9uZW50LCB3YXRjaGVkUHJvcGVydGllcykgPT4gbmV3IFByb3h5KFxuICAgIHt9LFxuICAgIHtcbiAgICAgIC8qXG4gICAgICAgKiBXaXRob3V0IHRoaXMsIG1ha2VQcm92aXNpb25hbFZhbHVlKCkgd2lsbCB0aHJvdyBvbiBhY2Nlc3NpbmdcbiAgICAgICAqIG5vbi1leGlzdGVudCBwcm9wXG4gICAgICAgKi9cbiAgICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4gdHlwZW9mIHByb3AgPT09IFwic3RyaW5nXCIgfHwgcHJvcCBpbiB0YXJnZXQsXG4gICAgICBnZXQ6ICh0YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3ApO1xuICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09IFwic3ltYm9sXCIgfHwgcHJvcCBpbiBQcm9taXNlLnByb3RvdHlwZSlcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGlmIChwcm9wIGluIHRhcmdldClcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIHdhdGNoZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgKSxcbiAgLy8gVXBkYXRlIEFjY2Vzc29yIG9uIGNvbXBvbmVudCBwcm9wIGNoYW5nZVxuICB3YXRjaENvbXBvbmVudFVwZGF0ZXMoY29udHJvbGxlciwgaW5zdGFuY2UsIHdhdGNoZWRQcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgcmVhZG9ubHlQcm9wcyA9IGZpbmRSZWFkT25seUFjY2Vzc29yUHJvcHMoaW5zdGFuY2UpO1xuICAgIGNvbnN0IGdldHRlciA9IChfdmFsdWUsIHByb3BlcnR5TmFtZSkgPT4gaW5zdGFuY2VbcHJvcGVydHlOYW1lXTtcbiAgICBjb25zdCBzZXR0ZXIgPSAobmV3VmFsdWUsIF9vbGRWYWx1ZSwgcHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICBpZiAoaW5zdGFuY2VbcHJvcGVydHlOYW1lXSA9PT0gbmV3VmFsdWUpXG4gICAgICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgICAgIGluc3RhbmNlW3Byb3BlcnR5TmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgIHJldHVybiBpbnN0YW5jZVtwcm9wZXJ0eU5hbWVdO1xuICAgIH07XG4gICAgY29uc3QgeyBjb21wb25lbnQgfSA9IGNvbnRyb2xsZXI7XG4gICAgd2F0Y2hlZFByb3BlcnRpZXMuZm9yRWFjaCgocHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICBpZiAoIXJlYWRvbmx5UHJvcHMuaGFzKHByb3BlcnR5TmFtZSkpXG4gICAgICAgIGNvbXBvbmVudFtwcm9wZXJ0eU5hbWVdID0gY29tcG9uZW50W3Byb3BlcnR5TmFtZV0gfHwgaW5zdGFuY2VbcHJvcGVydHlOYW1lXTtcbiAgICAgIGNvbnRyb2xsZXIuaW50ZXJuYWxzLmFjY2Vzc29yR2V0dGVyW3Byb3BlcnR5TmFtZV0gPSBnZXR0ZXI7XG4gICAgICBjb250cm9sbGVyLmludGVybmFscy5hY2Nlc3NvclNldHRlcltwcm9wZXJ0eU5hbWVdID0gc2V0dGVyO1xuICAgIH0pO1xuICB9LFxuICAvLyBVcGRhdGUgY29tcG9uZW50IG9uIEFjY2Vzc29yIHByb3AgY2hhbmdlXG4gIHdhdGNoQWNjZXNzb3JVcGRhdGVzKGNvbnRyb2xsZXIsIGluc3RhbmNlLCB3YXRjaGVkUHJvcGVydGllcykge1xuICAgIGNvbnN0IHsgY29tcG9uZW50IH0gPSBjb250cm9sbGVyO1xuICAgIGNvbXBvbmVudC5tYW5hZ2VyLmJ5cGFzc0dldHRlcihcbiAgICAgICgpID0+IHdhdGNoZWRQcm9wZXJ0aWVzLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gICAgICAgIGNvbnN0IGRvbVZhbHVlID0gY29tcG9uZW50W3Byb3BlcnR5XTtcbiAgICAgICAgY29uc3QgbW9kZWxWYWx1ZSA9IGluc3RhbmNlW3Byb3BlcnR5XTtcbiAgICAgICAgaWYgKGRvbVZhbHVlICE9IG51bGwgJiYgbW9kZWxWYWx1ZSAhPT0gZG9tVmFsdWUpXG4gICAgICAgICAgaW5zdGFuY2VbcHJvcGVydHldID0gZG9tVmFsdWU7XG4gICAgICB9KVxuICAgICk7XG4gICAgY29udHJvbGxlci5vbkxpZmVjeWNsZShcbiAgICAgICgpID0+IEFycmF5LmZyb20oXG4gICAgICAgIHdhdGNoZWRQcm9wZXJ0aWVzLFxuICAgICAgICAoYWxpYXNOYW1lKSA9PiBjb250cm9sbGVyLnJlYWN0aXZlVXRpbHMud2F0Y2goXG4gICAgICAgICAgKCkgPT4gaW5zdGFuY2VbYWxpYXNOYW1lXSxcbiAgICAgICAgICAoKSA9PiB3YXRjaENhbGxiYWNrKGNvbXBvbmVudCwgaW5zdGFuY2UsIGFsaWFzTmFtZSksXG4gICAgICAgICAgeyBpbml0aWFsOiB0cnVlIH1cbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH0sXG4gIGdhdGhlclBhcmFtZXRlcnMoY29udHJvbGxlciwgd2F0Y2hlZFByb3BlcnRpZXMpIHtcbiAgICBjb25zdCB7IGNvbXBvbmVudCB9ID0gY29udHJvbGxlcjtcbiAgICBjb25zdCBkYXRhID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgQXJyYXkuZnJvbSh3YXRjaGVkUHJvcGVydGllcywgKGtleSkgPT4gW2tleSwgY29tcG9uZW50W2tleV1dKS5maWx0ZXIoXG4gICAgICAgIChbLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB2b2lkIDBcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiBkYXRhIDtcbiAgfVxufTtcbmZ1bmN0aW9uIGZpbmRSZWFkT25seUFjY2Vzc29yUHJvcHMoaW5zdGFuY2UpIHtcbiAgY29uc3QgYWNjZXNzb3IgPSBpbnN0YW5jZTtcbiAgY29uc3QgcHJvcGVydGllcyA9IE9iamVjdC5lbnRyaWVzKGFjY2Vzc29yLl9fYWNjZXNzb3JfXz8ubWV0YWRhdGEgPz8ge30pO1xuICByZXR1cm4gbmV3IFNldChcbiAgICBwcm9wZXJ0aWVzLmZpbHRlcigoW19wcm9wZXJ0eSwgZGVzY3JpcHRvcl0pID0+IGRlc2NyaXB0b3I/LnJlYWRPbmx5ID09PSB0cnVlKS5tYXAoKFtwcm9wZXJ0eV0pID0+IHByb3BlcnR5KVxuICApO1xufVxuZnVuY3Rpb24gd2F0Y2hDYWxsYmFjayhjb21wb25lbnQsIGluc3RhbmNlLCBwcm9wZXJ0eSkge1xuICBjb25zdCBuZXdWYWx1ZSA9IGluc3RhbmNlW3Byb3BlcnR5XTtcbiAgY29tcG9uZW50W3Byb3BlcnR5XSA9IG5ld1ZhbHVlO1xufVxuZnVuY3Rpb24gdXNlVDluKHtcbiAgYmxvY2tpbmcgPSBmYWxzZSxcbiAgbmFtZVxufSA9IHt9KSB7XG4gIHJldHVybiBtYWtlQ29udHJvbGxlcigoY29tcG9uZW50LCBjb250cm9sbGVyKSA9PiB7XG4gICAgY29udHJvbGxlci5vbkxpZmVjeWNsZShcbiAgICAgICgpID0+IHN0YXJ0TG9jYWxlT2JzZXJ2ZXIoXG4gICAgICAgIGNvbXBvbmVudC5lbCxcbiAgICAgICAgZ2V0QXNzZXRQYXRoKFwiLi9hc3NldHNcIiksXG4gICAgICAgICh7IHQ5bkxvY2FsZSwgdDluU3RyaW5ncywgbGFuZyB9KSA9PiB7XG4gICAgICAgICAgY29udHJvbGxlci5leHBvcnRzID0geyAuLi50OW5TdHJpbmdzLCBfbGFuZzogbGFuZywgX3Q5bkxvY2FsZTogdDluTG9jYWxlIH07XG4gICAgICAgICAgY29uc3QgbGFiZWwgPSB0OW5TdHJpbmdzLmNvbXBvbmVudExhYmVsID8/IHQ5blN0cmluZ3Mud2lkZ2V0TGFiZWw7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsYWJlbCA9PT0gXCJzdHJpbmdcIiAmJiBcImxhYmVsXCIgaW4gY29tcG9uZW50ICYmIGNvbXBvbmVudC5sYWJlbCA9PSBudWxsKVxuICAgICAgICAgICAgY29tcG9uZW50LmxhYmVsID8/IChjb21wb25lbnQubGFiZWwgPSBsYWJlbCk7XG4gICAgICAgIH0sXG4gICAgICAgIG5hbWVcbiAgICAgIClcbiAgICApO1xuICAgIGlmIChibG9ja2luZylcbiAgICAgIHJldHVybiBjb250cm9sbGVyLnJlYWR5O1xuICAgIGNvbnN0IGxvY2FsZSA9IGdldEVsZW1lbnRMb2NhbGVzKGNvbXBvbmVudC5lbCk7XG4gICAgcmV0dXJuIHsgX2xhbmc6IGxvY2FsZS5sYW5nLCBfdDluTG9jYWxlOiBsb2NhbGUudDluTG9jYWxlIH07XG4gIH0pO1xufVxuXG4vLyBzcmMvdXNlUHJvcGVydHlDaGFuZ2UudHNcbnZhciB1c2VQcm9wZXJ0eUNoYW5nZSA9IChfY29tcG9uZW50KSA9PiBwcm9wZXJ0eUNoYW5nZUNvbnRyb2xsZXI7XG52YXIgZXZlbnROYW1lID0gXCJhcmNnaXNQcm9wZXJ0eUNoYW5nZVwiO1xudmFyIHByb3BlcnR5Q2hhbmdlQ29udHJvbGxlciA9ICguLi50b1dhdGNoKSA9PiBtYWtlQ29udHJvbGxlcigoY29tcG9uZW50LCBjb250cm9sbGVyKSA9PiB7XG4gIGNvbnN0IGV2ZW50RW1pdHRlciA9IGNvbXBvbmVudFtldmVudE5hbWVdO1xuICBjb250cm9sbGVyLm9uTG9hZChcbiAgICAoKSA9PiBjb250cm9sbGVyLm9uTGlmZWN5Y2xlKFxuICAgICAgKCkgPT4gdG9XYXRjaC5tYXAoXG4gICAgICAgIChuYW1lKSA9PiAoXG4gICAgICAgICAgLy8gQ2FzdGluZyB0byAnZWwnIHRvIHNpbXBsaWZ5IGR5bmFtaWMgcHJvcCBuYW1lIHR5cGluZ1xuICAgICAgICAgIGNvbXBvbmVudC5tYW5hZ2VyLndhdGNoKG5hbWUsICgpID0+IGV2ZW50RW1pdHRlci5lbWl0KHsgbmFtZSB9KSlcbiAgICAgICAgKVxuICAgICAgKVxuICAgIClcbiAgKTtcbiAgcmV0dXJuIGV2ZW50RW1pdHRlcjtcbn0pO1xuXG5leHBvcnQgeyBBY2Nlc3NvckNvbnRyb2xsZXIgYXMgQSwgYWNjZXNzb3JJbnRlcm5hbHMgYXMgYSwgdXNlUHJvcGVydHlDaGFuZ2UgYXMgYiwgdXNlVDluIGFzIGMsIGxvYWQgYXMgbCwgcHJveHlFeHBvcnRzIGFzIHAsIHVzZUNvbnRyb2xsZXJNYW5hZ2VyIGFzIHUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==