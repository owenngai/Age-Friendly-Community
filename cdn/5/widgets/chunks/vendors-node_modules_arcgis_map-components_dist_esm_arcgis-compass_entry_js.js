"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-node_modules_arcgis_map-components_dist_esm_arcgis-compass_entry_js"],{

/***/ "./node_modules/@arcgis/map-components/dist/esm/arcgis-compass.entry.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@arcgis/map-components/dist/esm/arcgis-compass.entry.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_compass: () => (/* binding */ ArcgisCompass)
/* harmony export */ });
/* harmony import */ var _index_6e172aac_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-6e172aac.js */ "./node_modules/@arcgis/map-components/dist/esm/index-6e172aac.js");
/* harmony import */ var _index_0bc55ca5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-0bc55ca5.js */ "./node_modules/@arcgis/map-components/dist/esm/index-0bc55ca5.js");
/* harmony import */ var _chunk_WQTCUXBS_9ec3781a_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-WQTCUXBS-9ec3781a.js */ "./node_modules/@arcgis/map-components/dist/esm/chunk-WQTCUXBS-9ec3781a.js");
/* harmony import */ var _index_7d72018f_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index-7d72018f.js */ "./node_modules/@arcgis/map-components/dist/esm/index-7d72018f.js");
/* harmony import */ var _component_utils_23194f7c_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./component-utils-23194f7c.js */ "./node_modules/@arcgis/map-components/dist/esm/component-utils-23194f7c.js");
/*!
 * All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * See https://js.arcgis.com/4.30/esri/copyright.txt for details.
 * v4.30.0-next.37
 */






// FIXME: auto-destroy widget?
/**
 * A controller for a wrapped JS API Widget
 * - loads the widget
 * - initializes the widget with the component's properties
 * - does two-way binding between widget and component properties
 * - re-emits the widgets's events on the component
 * - type-checks everything âœ¨
 *
 * Documentation:
 * https://devtopia.esri.com/WebGIS/arcgis-web-components/blob/main/packages/map-components/src/controllers/useWidget.md
 */
const makeWidgetController = (loadWidget, _options) => (component) => proxy(component, loadWidget);
class WidgetController extends _chunk_WQTCUXBS_9ec3781a_js__WEBPACK_IMPORTED_MODULE_2__.A {
    constructor(component, _loadAccessor) {
        super(component, _loadAccessor);
        this._watchedViewModelProperties = new Set();
        this._watchedVisibleElementsProperties = {};
        Object.defineProperty(this.exports, "viewModel", {
            value: _chunk_WQTCUXBS_9ec3781a_js__WEBPACK_IMPORTED_MODULE_2__.a.makeGetterProxy(component, this._watchedViewModelProperties),
        });
        Object.defineProperty(this.exports, "visibleElements", {
            value: this._makeVisibleElementsBinder(),
        });
    }
    hostConnected() {
        if (this.component.manager.didLoadCalled)
            (0,_component_utils_23194f7c_js__WEBPACK_IMPORTED_MODULE_4__.c)(this.component);
    }
    async hostLoad() {
        this.component.render = () => (0,_index_6e172aac_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null);
        /*
         * "viewModel" property might not have a @State(), so two-way binding might
         * not work (and probably one way is fine)
         */
        this._watchedProperties.delete("viewModel");
        await super.hostLoad();
        this._watchMetaProperties();
        this._reEmitWidgetEvents();
        // Do one way watching for viewModel property
        this.onLifecycle(() => this.reactiveUtils.watch(() => this._instance.viewModel, (newViewModel) => {
            this.component.viewModel = newViewModel;
        }, { initial: true }));
        const viewModel = this._instance.viewModel;
        if (typeof viewModel === "object") {
            _chunk_WQTCUXBS_9ec3781a_js__WEBPACK_IMPORTED_MODULE_2__.a.watchComponentUpdates(this, viewModel, this._watchedViewModelProperties);
            _chunk_WQTCUXBS_9ec3781a_js__WEBPACK_IMPORTED_MODULE_2__.a.watchAccessorUpdates(this, viewModel, this._watchedViewModelProperties);
            const parameters = _chunk_WQTCUXBS_9ec3781a_js__WEBPACK_IMPORTED_MODULE_2__.a.gatherParameters(this, this._watchedViewModelProperties);
            viewModel.set(parameters);
        }
        else if (this._watchedViewModelProperties.size > 0)
            throw new Error(`The widget does not have a viewModel to bind to. Tried to bind the following properties: ${Array.from(this._watchedViewModelProperties).join(", ")}`);
        const visibleElements = Object.entries(this._watchedVisibleElementsProperties);
        if (visibleElements.length > 0) {
            this.onLifecycle(() => visibleElements.map(([prop, propertyChain]) => {
                let base = this._instance.visibleElements ?? {};
                let defaultVisible = undefined;
                for (const key of propertyChain.slice(0, -1)) {
                    if (typeof base[key] === "object" && base[key] !== null)
                        base = base[key];
                    else {
                        defaultVisible = Boolean(base[key]);
                        break;
                    }
                }
                if (defaultVisible === undefined)
                    defaultVisible = Boolean(base[propertyChain.slice(-1)[0]] ?? true);
                prop.startsWith("hide") ? !defaultVisible : defaultVisible;
                const hideShowInName = prop.startsWith("hide") || prop.startsWith("show");
                const shouldFlip = hideShowInName ? prop.startsWith("hide") : defaultVisible;
                const genericComponent = this.component;
                if (typeof genericComponent[prop] === "boolean")
                    this._updateWidgetVisibleElement(propertyChain, genericComponent[prop], shouldFlip);
                else
                    genericComponent[prop] = false;
                return this.watch(prop, (rawVisible) => this._updateWidgetVisibleElement(propertyChain, rawVisible, shouldFlip));
            }));
        }
    }
    _updateWidgetVisibleElement(propertyChain, propValue, shouldFlip) {
        let base = this._instance.visibleElements ?? {};
        for (const key of propertyChain.slice(0, -1)) {
            if (typeof base[key] !== "object" || base[key] === null)
                base[key] = {};
            base = base[key];
        }
        const visible = Boolean(shouldFlip ? !propValue : propValue);
        base[propertyChain.at(-1)] = visible;
    }
    // This can't be in hostLoad as childElem is only accessible after first render
    hostLoaded() {
        const { el } = this.component;
        const childNode = el.shadowRoot?.firstChild ?? el.firstChild ?? undefined;
        /*
         * On hot reloading, new this.component instance is created (so properties
         * are reset) but this.component.el instance is preserved (so properties are
         * preserved). Since childElem is re-parented on 1st hostLoad(),
         * for it to be accessible on the 2nd hostLoad() (hot reload), we have to
         * store it's reference on the el, rather than component
         */
        el.childElem = childNode ?? el.childElem;
        this.component.childElem = el.childElem;
        this._instance.container = this.component.childElem ?? this.component.el;
        if (el.childElem === undefined && "production" !== "production")
            {}
        // Define the "view" property if not already present for compatibility with JS API
        if (!("view" in this.component))
            Object.defineProperty(this.component, "view", {
                get: () => this._instance.view ?? this._instance.viewModel?.view,
                set: (view) => {
                    if (!("view" in this._instance) && typeof this._instance.viewModel === "object")
                        this._instance.viewModel.view = view;
                    else
                        this._instance.view = view;
                },
            });
        (0,_component_utils_23194f7c_js__WEBPACK_IMPORTED_MODULE_4__.c)(this.component);
        this.component.arcgisReady.emit();
    }
    _watchMetaProperties() {
        this.watch("position", (position) => {
            if (this.component.childElem != null && typeof position === "string")
                this.component.view?.ui.move(this.component.childElem, position);
        });
        this.watch("referenceElement", (referenceElement) => void (0,_component_utils_23194f7c_js__WEBPACK_IMPORTED_MODULE_4__.r)(this.component, referenceElement).catch(console.error));
    }
    _reEmitWidgetEvents() {
        const isEvented = "on" in this._instance && typeof this._instance.on === "function";
        if (!isEvented)
            return;
        const eventTarget = this._instance;
        Object.entries(this.component).forEach(([key, unknown]) => {
            const value = unknown;
            if (!key.startsWith("widget") ||
                key === "widget" ||
                typeof value !== "object" ||
                value === null ||
                !("emit" in value) ||
                typeof value.emit !== "function")
                return;
            const emit = value.emit;
            const trimmedEventName = key.slice("widget".length);
            const capitalizedEventName = (0,_index_7d72018f_js__WEBPACK_IMPORTED_MODULE_3__.k)(trimmedEventName);
            const eventName = `${capitalizedEventName[0].toLowerCase()}${capitalizedEventName.slice(1)}`;
            this.onLifecycle(() => this.reactiveUtils.on(() => eventTarget, eventName, emit));
        });
    }
    hostDisconnected() {
        if (typeof this.component.childElem === "object")
            this.component.view?.ui.remove(this.component.childElem);
    }
    _makeVisibleElementsBinder() {
        return new Proxy({}, {
            has: (target, prop) => typeof prop === "string" || Reflect.has(target, prop),
            get: (target, prop) => {
                // Possibly called by the JS engine
                if (typeof prop === "symbol" || prop in Promise.prototype)
                    return Reflect.get(target, prop);
                const propertyChain = [prop];
                const proxy = this._makeRecursiveProxy(propertyChain);
                return this.component.manager.trackPropKey((resolvedKey) => {
                    if (resolvedKey === undefined)
                        throw new Error("Unable to bind visibleElements property. Check for incorrect this.widget.visibleElements usage");
                    this.component[resolvedKey] = false;
                    this._watchedVisibleElementsProperties[resolvedKey] = propertyChain;
                }, proxy, true);
            },
        });
    }
    _makeRecursiveProxy(propertyChain) {
        const chain = new Proxy({}, {
            get: (target, prop) => {
                const value = Reflect.get(target, prop);
                // Possibly called by the JS engine
                if (typeof prop === "symbol" || prop in Promise.prototype)
                    return value;
                propertyChain.push(prop);
                return chain;
            },
        });
        return chain;
    }
}
const proxy = (0,_chunk_WQTCUXBS_9ec3781a_js__WEBPACK_IMPORTED_MODULE_2__.p)(WidgetController);

const compassCss = "";

const isOrientationEqual = (a, b) => a.z === b.z && a.y === b.y && a.x === b.x;
const useCompassWidget = makeWidgetController(_index_0bc55ca5_js__WEBPACK_IMPORTED_MODULE_1__.k);
const ArcgisCompass = class {
    constructor(hostRef) {
        (0,_index_6e172aac_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisReady = (0,_index_6e172aac_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisReady", 7);
        this.arcgisPropertyChange = (0,_index_6e172aac_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisPropertyChange", 7);
        this.manager = (0,_chunk_WQTCUXBS_9ec3781a_js__WEBPACK_IMPORTED_MODULE_2__.u)(this);
        this.reactiveUtils = (0,_chunk_WQTCUXBS_9ec3781a_js__WEBPACK_IMPORTED_MODULE_2__.l)(_index_0bc55ca5_js__WEBPACK_IMPORTED_MODULE_1__.i);
        this.widget = useCompassWidget(this);
        this.viewModel = this.widget.viewModel;
        this.arcgisPropertyChange = (0,_chunk_WQTCUXBS_9ec3781a_js__WEBPACK_IMPORTED_MODULE_2__.b)()("orientation");
        this.icon = this.widget.icon;
        this.label = this.widget.label;
        this.orientation = this.manager.getSet(
        // Assertion needed because JS API's type is "any"
        this.viewModel.orientation, {
            set: (newValue, oldValue) => (isOrientationEqual(newValue ?? {}, oldValue ?? {}) ? oldValue : newValue),
        });
        this.position = "bottom-left";
        this.referenceElement = undefined;
        this.state = this.viewModel.state;
    }
    //--------------------------------------------------------------------------
    //
    //  Methods
    //
    //--------------------------------------------------------------------------
    async reset() {
        this.widget.reset();
    }
    get el() { return (0,_index_6e172aac_js__WEBPACK_IMPORTED_MODULE_0__.g)(this); }
};
ArcgisCompass.style = compassCss;




/***/ }),

/***/ "./node_modules/@arcgis/map-components/dist/esm/component-utils-23194f7c.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@arcgis/map-components/dist/esm/component-utils-23194f7c.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ addHandles),
/* harmony export */   b: () => (/* binding */ isNotSameViewpoint),
/* harmony export */   c: () => (/* binding */ checkForView),
/* harmony export */   d: () => (/* binding */ checkForExpand),
/* harmony export */   e: () => (/* binding */ isNotSameCamera),
/* harmony export */   f: () => (/* binding */ isNotSameEnvironment),
/* harmony export */   g: () => (/* binding */ isValidInteger),
/* harmony export */   i: () => (/* binding */ isNullOrEmptyString),
/* harmony export */   r: () => (/* binding */ referenceElementHelper)
/* harmony export */ });
/*!
 * All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * See https://js.arcgis.com/4.30/esri/copyright.txt for details.
 * v4.30.0-next.37
 */
function checkForExpand(element) {
    const expandRef = element.el.closest("arcgis-expand") ?? element.expandElem;
    if (expandRef?.widget) {
        element.view = expandRef.view;
        expandRef.widget.content = element.childElem ?? element.el;
        // TODO: Update to be expandIcon = widget.icon, not ready yet in 4.27next
        if (!expandRef.expandIcon) {
            expandRef.widget.expandIcon = element.widget ? element.widget.icon : element?.icon;
        }
        return true;
    }
    if (expandRef) {
        const widgetHandler = () => {
            expandRef.removeEventListener("arcgisExpandReady", widgetHandler, false);
            element.view = expandRef.view;
            expandRef.widget.content = element.childElem ?? element.el;
            if (!expandRef.expandIcon) {
                expandRef.widget.expandIcon = element.widget ? element.widget.icon : element?.icon;
            }
        };
        expandRef.addEventListener("arcgisExpandReady", widgetHandler, false);
        return true;
    }
    return false;
}

//--------------------------------------------------------------------------
//
//  Public Methods
//
//--------------------------------------------------------------------------
function addHandles(element, handle) {
    if (Array.isArray(handle)) {
        element._watchHandles = [...element._watchHandles, ...handle];
    }
    else {
        element._watchHandles.push(handle);
    }
}
function checkForView(element) {
    let isUsingReferenceElement = false;
    if (!checkForExpand(element)) {
        let viewRef = element.el.closest("arcgis-map") ?? element.el.closest("arcgis-scene");
        if (!viewRef && typeof element.referenceElement === "string") {
            viewRef = document.querySelector(element.referenceElement);
            isUsingReferenceElement = true;
        }
        if (viewRef?.view) {
            element.view = viewRef.view;
            const el = element.childElem ?? element.el;
            if (!isUsingReferenceElement) {
                element.view.ui.add(el, element.position);
            }
        }
        else if (viewRef) {
            waitForViewHandler(viewRef, element, isUsingReferenceElement);
        }
    }
    else {
        const viewRef = element.el.closest("arcgis-map") ?? element.el.closest("arcgis-scene");
        if (viewRef?.view) {
            element.view = viewRef.view;
        }
        else if (viewRef) {
            const handler = () => {
                viewRef.removeEventListener("arcgisViewReadyChange", handler, false);
                element.view = viewRef.view;
            };
            viewRef.addEventListener("arcgisViewReadyChange", handler, false);
        }
    }
}
function isNullOrEmptyString(value) {
    return value === undefined || value === null || value === "";
}
function isValidInteger(value) {
    return value != null && value % 1 === 0;
}
function isNotSameCamera(camera, camera2) {
    return (camera2 === undefined ||
        camera.position !== camera2.position ||
        camera.heading !== camera2.heading ||
        camera.tilt !== camera2.tilt);
}
function isNotSameEnvironment(environment, environment2) {
    return (environment2 === undefined ||
        environment2.atmosphereEnabled !== environment.atmosphereEnabled ||
        environment2.lighting.date !== environment.lighting.date ||
        environment2.lighting.directShadowsEnabled !==
            environment.lighting.directShadowsEnabled ||
        environment2.lighting.cameraTrackingEnabled !==
            environment.lighting.cameraTrackingEnabled ||
        environment2.lighting.date !== environment.lighting.date ||
        environment2.lighting.displayUTCOffset !==
            environment.lighting.displayUTCOffset);
}
function isNotSameViewpoint(viewpoint, viewpoint2) {
    return (viewpoint2 === undefined ||
        viewpoint.targetGeometry !== viewpoint2.targetGeometry ||
        viewpoint.rotation !== viewpoint2.rotation ||
        viewpoint.scale !== viewpoint2.scale);
}
async function updateForView(viewStr) {
    const viewRef = document.querySelector(viewStr);
    return await new Promise((resolve) => {
        if (viewRef?.view !== undefined) {
            resolve(viewRef.view);
        }
        else if (viewRef) {
            const handler = () => {
                viewRef.removeEventListener("arcgisViewReadyChange", handler, false);
                resolve(viewRef.view);
            };
            viewRef.addEventListener("arcgisViewReadyChange", handler, false);
        }
    });
}
async function referenceElementHelper(element, refElement) {
    if (refElement === undefined)
        return;
    else if (typeof refElement === "string") {
        element.view = await updateForView(refElement);
    }
    else if (element.widget) {
        element.view = refElement.view;
    }
}
//--------------------------------------------------------------------------
//
//  Private Methods
//
//--------------------------------------------------------------------------
function waitForViewHandler(viewRef, element, isUsingRefernceElement) {
    const handler = () => {
        viewRef.removeEventListener("arcgisViewReadyChange", handler, false);
        element.view = viewRef.view;
        if (!isUsingRefernceElement) {
            element.view.ui.add(element.childElem ?? element.el, element.position);
        }
    };
    viewRef.addEventListener("arcgisViewReadyChange", handler, false);
}




/***/ }),

/***/ "./node_modules/@arcgis/map-components/dist/esm/index-7d72018f.js":
/*!************************************************************************!*\
  !*** ./node_modules/@arcgis/map-components/dist/esm/index-7d72018f.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ classes),
/* harmony export */   k: () => (/* binding */ kebabToPascal)
/* harmony export */ });
/*!
 * All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * See https://js.arcgis.com/4.30/esri/copyright.txt for details.
 * v4.30.0-next.37
 */
// src/array-utils.ts

// src/css-utils.ts
function classes(...classes2) {
  const effectiveClasses = [];
  for (let i = 0; i < classes2.length; i++) {
    const arg = classes2[i];
    if (typeof arg === "string") {
      effectiveClasses.push(arg);
    } else if (Array.isArray(arg)) {
      effectiveClasses.push.apply(effectiveClasses, arg);
    } else if (typeof arg === "object") {
      for (const prop in arg) {
        if (arg[prop]) {
          effectiveClasses.push(prop);
        }
      }
    }
  }
  const className = effectiveClasses.join(" ");
  effectiveClasses.length = 0;
  return className;
}

// src/text.ts
var kebabToPascal = (name) => name.split("-").map((part) => (part[0]?.toLocaleUpperCase() ?? "") + part.slice(1)).join("");
var capitalize = (string) => string.charAt(0).toUpperCase() + string.slice(1);
var camelToHuman = (value) => capitalize(value.replaceAll(/([a-z])([A-Z])/gu, "$1 $2"));
new Proxy(
  {},
  {
    get: (_target, property) => camelToHuman(property.toString())
  }
);




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvdmVuZG9ycy1ub2RlX21vZHVsZXNfYXJjZ2lzX21hcC1jb21wb25lbnRzX2Rpc3RfZXNtX2FyY2dpcy1jb21wYXNzX2VudHJ5X2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0c7QUFDUDtBQUNxRjtBQUN2SDtBQUNzQzs7QUFFL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMERBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMERBQWlCO0FBQ3BDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQVk7QUFDeEI7QUFDQTtBQUNBLHNDQUFzQyxxREFBQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJLGVBQWU7QUFDNUI7QUFDQTtBQUNBLFlBQVksMERBQWlCO0FBQzdCLFlBQVksMERBQWlCO0FBQzdCLCtCQUErQiwwREFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esd0hBQXdILHdEQUF3RDtBQUNoTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksRUFBc0U7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixRQUFRLCtEQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxrRUFBa0UsK0RBQXNCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMscURBQWE7QUFDdEQsaUNBQWlDLHNDQUFzQyxFQUFFLDhCQUE4QjtBQUN2RztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4REFBWTs7QUFFMUI7O0FBRUE7QUFDQSw4Q0FBOEMsaURBQWlCO0FBQy9EO0FBQ0E7QUFDQSxRQUFRLHFEQUFnQjtBQUN4QiwyQkFBMkIscURBQVc7QUFDdEMsb0NBQW9DLHFEQUFXO0FBQy9DLHVCQUF1Qiw4REFBb0I7QUFDM0MsNkJBQTZCLDhEQUFJLENBQUMsaURBQXVCO0FBQ3pEO0FBQ0E7QUFDQSxvQ0FBb0MsOERBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsZ0JBQWdCO0FBQzNGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU8scURBQVU7QUFDaEM7QUFDQTs7QUFFMkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDek8zQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5Tjs7Ozs7Ozs7Ozs7Ozs7OztBQ3BKek47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvbWFwLWNvbXBvbmVudHMvZGlzdC9lc20vYXJjZ2lzLWNvbXBhc3MuZW50cnkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL21hcC1jb21wb25lbnRzL2Rpc3QvZXNtL2NvbXBvbmVudC11dGlscy0yMzE5NGY3Yy5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvbWFwLWNvbXBvbmVudHMvZGlzdC9lc20vaW5kZXgtN2Q3MjAxOGYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVzcmksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjMwL2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiAqIHY0LjMwLjAtbmV4dC4zN1xuICovXG5pbXBvcnQgeyBoLCByIGFzIHJlZ2lzdGVySW5zdGFuY2UsIGMgYXMgY3JlYXRlRXZlbnQsIGcgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtNmUxNzJhYWMuanMnO1xuaW1wb3J0IHsgayBhcyBuZXdXaWRnZXRzQ29tcGFzcywgaSBhcyBpbXBvcnRDb3JlUmVhY3RpdmVVdGlscyB9IGZyb20gJy4vaW5kZXgtMGJjNTVjYTUuanMnO1xuaW1wb3J0IHsgcCBhcyBwcm94eUV4cG9ydHMsIEEgYXMgQWNjZXNzb3JDb250cm9sbGVyLCBhIGFzIGFjY2Vzc29ySW50ZXJuYWxzLCB1IGFzIHVzZUNvbnRyb2xsZXJNYW5hZ2VyLCBsIGFzIGxvYWQsIGIgYXMgdXNlUHJvcGVydHlDaGFuZ2UgfSBmcm9tICcuL2NodW5rLVdRVENVWEJTLTllYzM3ODFhLmpzJztcbmltcG9ydCB7IGsgYXMga2ViYWJUb1Bhc2NhbCB9IGZyb20gJy4vaW5kZXgtN2Q3MjAxOGYuanMnO1xuaW1wb3J0IHsgYyBhcyBjaGVja0ZvclZpZXcsIHIgYXMgcmVmZXJlbmNlRWxlbWVudEhlbHBlciB9IGZyb20gJy4vY29tcG9uZW50LXV0aWxzLTIzMTk0ZjdjLmpzJztcblxuLy8gRklYTUU6IGF1dG8tZGVzdHJveSB3aWRnZXQ/XG4vKipcbiAqIEEgY29udHJvbGxlciBmb3IgYSB3cmFwcGVkIEpTIEFQSSBXaWRnZXRcbiAqIC0gbG9hZHMgdGhlIHdpZGdldFxuICogLSBpbml0aWFsaXplcyB0aGUgd2lkZ2V0IHdpdGggdGhlIGNvbXBvbmVudCdzIHByb3BlcnRpZXNcbiAqIC0gZG9lcyB0d28td2F5IGJpbmRpbmcgYmV0d2VlbiB3aWRnZXQgYW5kIGNvbXBvbmVudCBwcm9wZXJ0aWVzXG4gKiAtIHJlLWVtaXRzIHRoZSB3aWRnZXRzJ3MgZXZlbnRzIG9uIHRoZSBjb21wb25lbnRcbiAqIC0gdHlwZS1jaGVja3MgZXZlcnl0aGluZyDinKhcbiAqXG4gKiBEb2N1bWVudGF0aW9uOlxuICogaHR0cHM6Ly9kZXZ0b3BpYS5lc3JpLmNvbS9XZWJHSVMvYXJjZ2lzLXdlYi1jb21wb25lbnRzL2Jsb2IvbWFpbi9wYWNrYWdlcy9tYXAtY29tcG9uZW50cy9zcmMvY29udHJvbGxlcnMvdXNlV2lkZ2V0Lm1kXG4gKi9cbmNvbnN0IG1ha2VXaWRnZXRDb250cm9sbGVyID0gKGxvYWRXaWRnZXQsIF9vcHRpb25zKSA9PiAoY29tcG9uZW50KSA9PiBwcm94eShjb21wb25lbnQsIGxvYWRXaWRnZXQpO1xuY2xhc3MgV2lkZ2V0Q29udHJvbGxlciBleHRlbmRzIEFjY2Vzc29yQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50LCBfbG9hZEFjY2Vzc29yKSB7XG4gICAgICAgIHN1cGVyKGNvbXBvbmVudCwgX2xvYWRBY2Nlc3Nvcik7XG4gICAgICAgIHRoaXMuX3dhdGNoZWRWaWV3TW9kZWxQcm9wZXJ0aWVzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl93YXRjaGVkVmlzaWJsZUVsZW1lbnRzUHJvcGVydGllcyA9IHt9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5leHBvcnRzLCBcInZpZXdNb2RlbFwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogYWNjZXNzb3JJbnRlcm5hbHMubWFrZUdldHRlclByb3h5KGNvbXBvbmVudCwgdGhpcy5fd2F0Y2hlZFZpZXdNb2RlbFByb3BlcnRpZXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZXhwb3J0cywgXCJ2aXNpYmxlRWxlbWVudHNcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMuX21ha2VWaXNpYmxlRWxlbWVudHNCaW5kZXIoKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhvc3RDb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5tYW5hZ2VyLmRpZExvYWRDYWxsZWQpXG4gICAgICAgICAgICBjaGVja0ZvclZpZXcodGhpcy5jb21wb25lbnQpO1xuICAgIH1cbiAgICBhc3luYyBob3N0TG9hZCgpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQucmVuZGVyID0gKCkgPT4gaChcImRpdlwiLCBudWxsKTtcbiAgICAgICAgLypcbiAgICAgICAgICogXCJ2aWV3TW9kZWxcIiBwcm9wZXJ0eSBtaWdodCBub3QgaGF2ZSBhIEBTdGF0ZSgpLCBzbyB0d28td2F5IGJpbmRpbmcgbWlnaHRcbiAgICAgICAgICogbm90IHdvcmsgKGFuZCBwcm9iYWJseSBvbmUgd2F5IGlzIGZpbmUpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl93YXRjaGVkUHJvcGVydGllcy5kZWxldGUoXCJ2aWV3TW9kZWxcIik7XG4gICAgICAgIGF3YWl0IHN1cGVyLmhvc3RMb2FkKCk7XG4gICAgICAgIHRoaXMuX3dhdGNoTWV0YVByb3BlcnRpZXMoKTtcbiAgICAgICAgdGhpcy5fcmVFbWl0V2lkZ2V0RXZlbnRzKCk7XG4gICAgICAgIC8vIERvIG9uZSB3YXkgd2F0Y2hpbmcgZm9yIHZpZXdNb2RlbCBwcm9wZXJ0eVxuICAgICAgICB0aGlzLm9uTGlmZWN5Y2xlKCgpID0+IHRoaXMucmVhY3RpdmVVdGlscy53YXRjaCgoKSA9PiB0aGlzLl9pbnN0YW5jZS52aWV3TW9kZWwsIChuZXdWaWV3TW9kZWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnZpZXdNb2RlbCA9IG5ld1ZpZXdNb2RlbDtcbiAgICAgICAgfSwgeyBpbml0aWFsOiB0cnVlIH0pKTtcbiAgICAgICAgY29uc3Qgdmlld01vZGVsID0gdGhpcy5faW5zdGFuY2Uudmlld01vZGVsO1xuICAgICAgICBpZiAodHlwZW9mIHZpZXdNb2RlbCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgYWNjZXNzb3JJbnRlcm5hbHMud2F0Y2hDb21wb25lbnRVcGRhdGVzKHRoaXMsIHZpZXdNb2RlbCwgdGhpcy5fd2F0Y2hlZFZpZXdNb2RlbFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgYWNjZXNzb3JJbnRlcm5hbHMud2F0Y2hBY2Nlc3NvclVwZGF0ZXModGhpcywgdmlld01vZGVsLCB0aGlzLl93YXRjaGVkVmlld01vZGVsUHJvcGVydGllcyk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gYWNjZXNzb3JJbnRlcm5hbHMuZ2F0aGVyUGFyYW1ldGVycyh0aGlzLCB0aGlzLl93YXRjaGVkVmlld01vZGVsUHJvcGVydGllcyk7XG4gICAgICAgICAgICB2aWV3TW9kZWwuc2V0KHBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3dhdGNoZWRWaWV3TW9kZWxQcm9wZXJ0aWVzLnNpemUgPiAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgd2lkZ2V0IGRvZXMgbm90IGhhdmUgYSB2aWV3TW9kZWwgdG8gYmluZCB0by4gVHJpZWQgdG8gYmluZCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6ICR7QXJyYXkuZnJvbSh0aGlzLl93YXRjaGVkVmlld01vZGVsUHJvcGVydGllcykuam9pbihcIiwgXCIpfWApO1xuICAgICAgICBjb25zdCB2aXNpYmxlRWxlbWVudHMgPSBPYmplY3QuZW50cmllcyh0aGlzLl93YXRjaGVkVmlzaWJsZUVsZW1lbnRzUHJvcGVydGllcyk7XG4gICAgICAgIGlmICh2aXNpYmxlRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5vbkxpZmVjeWNsZSgoKSA9PiB2aXNpYmxlRWxlbWVudHMubWFwKChbcHJvcCwgcHJvcGVydHlDaGFpbl0pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgYmFzZSA9IHRoaXMuX2luc3RhbmNlLnZpc2libGVFbGVtZW50cyA/PyB7fTtcbiAgICAgICAgICAgICAgICBsZXQgZGVmYXVsdFZpc2libGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcHJvcGVydHlDaGFpbi5zbGljZSgwLCAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiYXNlW2tleV0gPT09IFwib2JqZWN0XCIgJiYgYmFzZVtrZXldICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2Vba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmlzaWJsZSA9IEJvb2xlYW4oYmFzZVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0VmlzaWJsZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmlzaWJsZSA9IEJvb2xlYW4oYmFzZVtwcm9wZXJ0eUNoYWluLnNsaWNlKC0xKVswXV0gPz8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcHJvcC5zdGFydHNXaXRoKFwiaGlkZVwiKSA/ICFkZWZhdWx0VmlzaWJsZSA6IGRlZmF1bHRWaXNpYmxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhpZGVTaG93SW5OYW1lID0gcHJvcC5zdGFydHNXaXRoKFwiaGlkZVwiKSB8fCBwcm9wLnN0YXJ0c1dpdGgoXCJzaG93XCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZEZsaXAgPSBoaWRlU2hvd0luTmFtZSA/IHByb3Auc3RhcnRzV2l0aChcImhpZGVcIikgOiBkZWZhdWx0VmlzaWJsZTtcbiAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmljQ29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBnZW5lcmljQ29tcG9uZW50W3Byb3BdID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlV2lkZ2V0VmlzaWJsZUVsZW1lbnQocHJvcGVydHlDaGFpbiwgZ2VuZXJpY0NvbXBvbmVudFtwcm9wXSwgc2hvdWxkRmxpcCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBnZW5lcmljQ29tcG9uZW50W3Byb3BdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2F0Y2gocHJvcCwgKHJhd1Zpc2libGUpID0+IHRoaXMuX3VwZGF0ZVdpZGdldFZpc2libGVFbGVtZW50KHByb3BlcnR5Q2hhaW4sIHJhd1Zpc2libGUsIHNob3VsZEZsaXApKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfdXBkYXRlV2lkZ2V0VmlzaWJsZUVsZW1lbnQocHJvcGVydHlDaGFpbiwgcHJvcFZhbHVlLCBzaG91bGRGbGlwKSB7XG4gICAgICAgIGxldCBiYXNlID0gdGhpcy5faW5zdGFuY2UudmlzaWJsZUVsZW1lbnRzID8/IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBwcm9wZXJ0eUNoYWluLnNsaWNlKDAsIC0xKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiYXNlW2tleV0gIT09IFwib2JqZWN0XCIgfHwgYmFzZVtrZXldID09PSBudWxsKVxuICAgICAgICAgICAgICAgIGJhc2Vba2V5XSA9IHt9O1xuICAgICAgICAgICAgYmFzZSA9IGJhc2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aXNpYmxlID0gQm9vbGVhbihzaG91bGRGbGlwID8gIXByb3BWYWx1ZSA6IHByb3BWYWx1ZSk7XG4gICAgICAgIGJhc2VbcHJvcGVydHlDaGFpbi5hdCgtMSldID0gdmlzaWJsZTtcbiAgICB9XG4gICAgLy8gVGhpcyBjYW4ndCBiZSBpbiBob3N0TG9hZCBhcyBjaGlsZEVsZW0gaXMgb25seSBhY2Nlc3NpYmxlIGFmdGVyIGZpcnN0IHJlbmRlclxuICAgIGhvc3RMb2FkZWQoKSB7XG4gICAgICAgIGNvbnN0IHsgZWwgfSA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBlbC5zaGFkb3dSb290Py5maXJzdENoaWxkID8/IGVsLmZpcnN0Q2hpbGQgPz8gdW5kZWZpbmVkO1xuICAgICAgICAvKlxuICAgICAgICAgKiBPbiBob3QgcmVsb2FkaW5nLCBuZXcgdGhpcy5jb21wb25lbnQgaW5zdGFuY2UgaXMgY3JlYXRlZCAoc28gcHJvcGVydGllc1xuICAgICAgICAgKiBhcmUgcmVzZXQpIGJ1dCB0aGlzLmNvbXBvbmVudC5lbCBpbnN0YW5jZSBpcyBwcmVzZXJ2ZWQgKHNvIHByb3BlcnRpZXMgYXJlXG4gICAgICAgICAqIHByZXNlcnZlZCkuIFNpbmNlIGNoaWxkRWxlbSBpcyByZS1wYXJlbnRlZCBvbiAxc3QgaG9zdExvYWQoKSxcbiAgICAgICAgICogZm9yIGl0IHRvIGJlIGFjY2Vzc2libGUgb24gdGhlIDJuZCBob3N0TG9hZCgpIChob3QgcmVsb2FkKSwgd2UgaGF2ZSB0b1xuICAgICAgICAgKiBzdG9yZSBpdCdzIHJlZmVyZW5jZSBvbiB0aGUgZWwsIHJhdGhlciB0aGFuIGNvbXBvbmVudFxuICAgICAgICAgKi9cbiAgICAgICAgZWwuY2hpbGRFbGVtID0gY2hpbGROb2RlID8/IGVsLmNoaWxkRWxlbTtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuY2hpbGRFbGVtID0gZWwuY2hpbGRFbGVtO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZS5jb250YWluZXIgPSB0aGlzLmNvbXBvbmVudC5jaGlsZEVsZW0gPz8gdGhpcy5jb21wb25lbnQuZWw7XG4gICAgICAgIGlmIChlbC5jaGlsZEVsZW0gPT09IHVuZGVmaW5lZCAmJiBcInByb2R1Y3Rpb25cIiAhPT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCByZWZlcmVuY2UgdG8gY29tcG9uZW50J3Mgcm9vdCBjaGlsZFwiKTtcbiAgICAgICAgLy8gRGVmaW5lIHRoZSBcInZpZXdcIiBwcm9wZXJ0eSBpZiBub3QgYWxyZWFkeSBwcmVzZW50IGZvciBjb21wYXRpYmlsaXR5IHdpdGggSlMgQVBJXG4gICAgICAgIGlmICghKFwidmlld1wiIGluIHRoaXMuY29tcG9uZW50KSlcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmNvbXBvbmVudCwgXCJ2aWV3XCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHRoaXMuX2luc3RhbmNlLnZpZXcgPz8gdGhpcy5faW5zdGFuY2Uudmlld01vZGVsPy52aWV3LFxuICAgICAgICAgICAgICAgIHNldDogKHZpZXcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoXCJ2aWV3XCIgaW4gdGhpcy5faW5zdGFuY2UpICYmIHR5cGVvZiB0aGlzLl9pbnN0YW5jZS52aWV3TW9kZWwgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS52aWV3TW9kZWwudmlldyA9IHZpZXc7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLnZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hlY2tGb3JWaWV3KHRoaXMuY29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuYXJjZ2lzUmVhZHkuZW1pdCgpO1xuICAgIH1cbiAgICBfd2F0Y2hNZXRhUHJvcGVydGllcygpIHtcbiAgICAgICAgdGhpcy53YXRjaChcInBvc2l0aW9uXCIsIChwb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50LmNoaWxkRWxlbSAhPSBudWxsICYmIHR5cGVvZiBwb3NpdGlvbiA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC52aWV3Py51aS5tb3ZlKHRoaXMuY29tcG9uZW50LmNoaWxkRWxlbSwgcG9zaXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53YXRjaChcInJlZmVyZW5jZUVsZW1lbnRcIiwgKHJlZmVyZW5jZUVsZW1lbnQpID0+IHZvaWQgcmVmZXJlbmNlRWxlbWVudEhlbHBlcih0aGlzLmNvbXBvbmVudCwgcmVmZXJlbmNlRWxlbWVudCkuY2F0Y2goY29uc29sZS5lcnJvcikpO1xuICAgIH1cbiAgICBfcmVFbWl0V2lkZ2V0RXZlbnRzKCkge1xuICAgICAgICBjb25zdCBpc0V2ZW50ZWQgPSBcIm9uXCIgaW4gdGhpcy5faW5zdGFuY2UgJiYgdHlwZW9mIHRoaXMuX2luc3RhbmNlLm9uID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIGlmICghaXNFdmVudGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBldmVudFRhcmdldCA9IHRoaXMuX2luc3RhbmNlO1xuICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLmNvbXBvbmVudCkuZm9yRWFjaCgoW2tleSwgdW5rbm93bl0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdW5rbm93bjtcbiAgICAgICAgICAgIGlmICgha2V5LnN0YXJ0c1dpdGgoXCJ3aWRnZXRcIikgfHxcbiAgICAgICAgICAgICAgICBrZXkgPT09IFwid2lkZ2V0XCIgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICEoXCJlbWl0XCIgaW4gdmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlLmVtaXQgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBlbWl0ID0gdmFsdWUuZW1pdDtcbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRFdmVudE5hbWUgPSBrZXkuc2xpY2UoXCJ3aWRnZXRcIi5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgY2FwaXRhbGl6ZWRFdmVudE5hbWUgPSBrZWJhYlRvUGFzY2FsKHRyaW1tZWRFdmVudE5hbWUpO1xuICAgICAgICAgICAgY29uc3QgZXZlbnROYW1lID0gYCR7Y2FwaXRhbGl6ZWRFdmVudE5hbWVbMF0udG9Mb3dlckNhc2UoKX0ke2NhcGl0YWxpemVkRXZlbnROYW1lLnNsaWNlKDEpfWA7XG4gICAgICAgICAgICB0aGlzLm9uTGlmZWN5Y2xlKCgpID0+IHRoaXMucmVhY3RpdmVVdGlscy5vbigoKSA9PiBldmVudFRhcmdldCwgZXZlbnROYW1lLCBlbWl0KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBob3N0RGlzY29ubmVjdGVkKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29tcG9uZW50LmNoaWxkRWxlbSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnZpZXc/LnVpLnJlbW92ZSh0aGlzLmNvbXBvbmVudC5jaGlsZEVsZW0pO1xuICAgIH1cbiAgICBfbWFrZVZpc2libGVFbGVtZW50c0JpbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiB0eXBlb2YgcHJvcCA9PT0gXCJzdHJpbmdcIiB8fCBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApLFxuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUG9zc2libHkgY2FsbGVkIGJ5IHRoZSBKUyBlbmdpbmVcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09IFwic3ltYm9sXCIgfHwgcHJvcCBpbiBQcm9taXNlLnByb3RvdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlDaGFpbiA9IFtwcm9wXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm94eSA9IHRoaXMuX21ha2VSZWN1cnNpdmVQcm94eShwcm9wZXJ0eUNoYWluKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQubWFuYWdlci50cmFja1Byb3BLZXkoKHJlc29sdmVkS2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZEtleSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGJpbmQgdmlzaWJsZUVsZW1lbnRzIHByb3BlcnR5LiBDaGVjayBmb3IgaW5jb3JyZWN0IHRoaXMud2lkZ2V0LnZpc2libGVFbGVtZW50cyB1c2FnZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRbcmVzb2x2ZWRLZXldID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dhdGNoZWRWaXNpYmxlRWxlbWVudHNQcm9wZXJ0aWVzW3Jlc29sdmVkS2V5XSA9IHByb3BlcnR5Q2hhaW47XG4gICAgICAgICAgICAgICAgfSwgcHJveHksIHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9tYWtlUmVjdXJzaXZlUHJveHkocHJvcGVydHlDaGFpbikge1xuICAgICAgICBjb25zdCBjaGFpbiA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3ApO1xuICAgICAgICAgICAgICAgIC8vIFBvc3NpYmx5IGNhbGxlZCBieSB0aGUgSlMgZW5naW5lXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSBcInN5bWJvbFwiIHx8IHByb3AgaW4gUHJvbWlzZS5wcm90b3R5cGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUNoYWluLnB1c2gocHJvcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYWluO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjaGFpbjtcbiAgICB9XG59XG5jb25zdCBwcm94eSA9IHByb3h5RXhwb3J0cyhXaWRnZXRDb250cm9sbGVyKTtcblxuY29uc3QgY29tcGFzc0NzcyA9IFwiXCI7XG5cbmNvbnN0IGlzT3JpZW50YXRpb25FcXVhbCA9IChhLCBiKSA9PiBhLnogPT09IGIueiAmJiBhLnkgPT09IGIueSAmJiBhLnggPT09IGIueDtcbmNvbnN0IHVzZUNvbXBhc3NXaWRnZXQgPSBtYWtlV2lkZ2V0Q29udHJvbGxlcihuZXdXaWRnZXRzQ29tcGFzcyk7XG5jb25zdCBBcmNnaXNDb21wYXNzID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICAgICAgdGhpcy5hcmNnaXNSZWFkeSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzUmVhZHlcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzUHJvcGVydHlDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1Byb3BlcnR5Q2hhbmdlXCIsIDcpO1xuICAgICAgICB0aGlzLm1hbmFnZXIgPSB1c2VDb250cm9sbGVyTWFuYWdlcih0aGlzKTtcbiAgICAgICAgdGhpcy5yZWFjdGl2ZVV0aWxzID0gbG9hZChpbXBvcnRDb3JlUmVhY3RpdmVVdGlscyk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gdXNlQ29tcGFzc1dpZGdldCh0aGlzKTtcbiAgICAgICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLndpZGdldC52aWV3TW9kZWw7XG4gICAgICAgIHRoaXMuYXJjZ2lzUHJvcGVydHlDaGFuZ2UgPSB1c2VQcm9wZXJ0eUNoYW5nZSgpKFwib3JpZW50YXRpb25cIik7XG4gICAgICAgIHRoaXMuaWNvbiA9IHRoaXMud2lkZ2V0Lmljb247XG4gICAgICAgIHRoaXMubGFiZWwgPSB0aGlzLndpZGdldC5sYWJlbDtcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9IHRoaXMubWFuYWdlci5nZXRTZXQoXG4gICAgICAgIC8vIEFzc2VydGlvbiBuZWVkZWQgYmVjYXVzZSBKUyBBUEkncyB0eXBlIGlzIFwiYW55XCJcbiAgICAgICAgdGhpcy52aWV3TW9kZWwub3JpZW50YXRpb24sIHtcbiAgICAgICAgICAgIHNldDogKG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4gKGlzT3JpZW50YXRpb25FcXVhbChuZXdWYWx1ZSA/PyB7fSwgb2xkVmFsdWUgPz8ge30pID8gb2xkVmFsdWUgOiBuZXdWYWx1ZSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gXCJib3R0b20tbGVmdFwiO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZUVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnZpZXdNb2RlbC5zdGF0ZTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyByZXNldCgpIHtcbiAgICAgICAgdGhpcy53aWRnZXQucmVzZXQoKTtcbiAgICB9XG4gICAgZ2V0IGVsKCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcbkFyY2dpc0NvbXBhc3Muc3R5bGUgPSBjb21wYXNzQ3NzO1xuXG5leHBvcnQgeyBBcmNnaXNDb21wYXNzIGFzIGFyY2dpc19jb21wYXNzIH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRXNyaSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9qcy5hcmNnaXMuY29tLzQuMzAvZXNyaS9jb3B5cmlnaHQudHh0IGZvciBkZXRhaWxzLlxuICogdjQuMzAuMC1uZXh0LjM3XG4gKi9cbmZ1bmN0aW9uIGNoZWNrRm9yRXhwYW5kKGVsZW1lbnQpIHtcbiAgICBjb25zdCBleHBhbmRSZWYgPSBlbGVtZW50LmVsLmNsb3Nlc3QoXCJhcmNnaXMtZXhwYW5kXCIpID8/IGVsZW1lbnQuZXhwYW5kRWxlbTtcbiAgICBpZiAoZXhwYW5kUmVmPy53aWRnZXQpIHtcbiAgICAgICAgZWxlbWVudC52aWV3ID0gZXhwYW5kUmVmLnZpZXc7XG4gICAgICAgIGV4cGFuZFJlZi53aWRnZXQuY29udGVudCA9IGVsZW1lbnQuY2hpbGRFbGVtID8/IGVsZW1lbnQuZWw7XG4gICAgICAgIC8vIFRPRE86IFVwZGF0ZSB0byBiZSBleHBhbmRJY29uID0gd2lkZ2V0Lmljb24sIG5vdCByZWFkeSB5ZXQgaW4gNC4yN25leHRcbiAgICAgICAgaWYgKCFleHBhbmRSZWYuZXhwYW5kSWNvbikge1xuICAgICAgICAgICAgZXhwYW5kUmVmLndpZGdldC5leHBhbmRJY29uID0gZWxlbWVudC53aWRnZXQgPyBlbGVtZW50LndpZGdldC5pY29uIDogZWxlbWVudD8uaWNvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGV4cGFuZFJlZikge1xuICAgICAgICBjb25zdCB3aWRnZXRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgZXhwYW5kUmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhcmNnaXNFeHBhbmRSZWFkeVwiLCB3aWRnZXRIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICBlbGVtZW50LnZpZXcgPSBleHBhbmRSZWYudmlldztcbiAgICAgICAgICAgIGV4cGFuZFJlZi53aWRnZXQuY29udGVudCA9IGVsZW1lbnQuY2hpbGRFbGVtID8/IGVsZW1lbnQuZWw7XG4gICAgICAgICAgICBpZiAoIWV4cGFuZFJlZi5leHBhbmRJY29uKSB7XG4gICAgICAgICAgICAgICAgZXhwYW5kUmVmLndpZGdldC5leHBhbmRJY29uID0gZWxlbWVudC53aWRnZXQgPyBlbGVtZW50LndpZGdldC5pY29uIDogZWxlbWVudD8uaWNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZXhwYW5kUmVmLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNFeHBhbmRSZWFkeVwiLCB3aWRnZXRIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vXG4vLyAgUHVibGljIE1ldGhvZHNcbi8vXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBhZGRIYW5kbGVzKGVsZW1lbnQsIGhhbmRsZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZSkpIHtcbiAgICAgICAgZWxlbWVudC5fd2F0Y2hIYW5kbGVzID0gWy4uLmVsZW1lbnQuX3dhdGNoSGFuZGxlcywgLi4uaGFuZGxlXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuX3dhdGNoSGFuZGxlcy5wdXNoKGhhbmRsZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tGb3JWaWV3KGVsZW1lbnQpIHtcbiAgICBsZXQgaXNVc2luZ1JlZmVyZW5jZUVsZW1lbnQgPSBmYWxzZTtcbiAgICBpZiAoIWNoZWNrRm9yRXhwYW5kKGVsZW1lbnQpKSB7XG4gICAgICAgIGxldCB2aWV3UmVmID0gZWxlbWVudC5lbC5jbG9zZXN0KFwiYXJjZ2lzLW1hcFwiKSA/PyBlbGVtZW50LmVsLmNsb3Nlc3QoXCJhcmNnaXMtc2NlbmVcIik7XG4gICAgICAgIGlmICghdmlld1JlZiAmJiB0eXBlb2YgZWxlbWVudC5yZWZlcmVuY2VFbGVtZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2aWV3UmVmID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtZW50LnJlZmVyZW5jZUVsZW1lbnQpO1xuICAgICAgICAgICAgaXNVc2luZ1JlZmVyZW5jZUVsZW1lbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aWV3UmVmPy52aWV3KSB7XG4gICAgICAgICAgICBlbGVtZW50LnZpZXcgPSB2aWV3UmVmLnZpZXc7XG4gICAgICAgICAgICBjb25zdCBlbCA9IGVsZW1lbnQuY2hpbGRFbGVtID8/IGVsZW1lbnQuZWw7XG4gICAgICAgICAgICBpZiAoIWlzVXNpbmdSZWZlcmVuY2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC52aWV3LnVpLmFkZChlbCwgZWxlbWVudC5wb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmlld1JlZikge1xuICAgICAgICAgICAgd2FpdEZvclZpZXdIYW5kbGVyKHZpZXdSZWYsIGVsZW1lbnQsIGlzVXNpbmdSZWZlcmVuY2VFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgdmlld1JlZiA9IGVsZW1lbnQuZWwuY2xvc2VzdChcImFyY2dpcy1tYXBcIikgPz8gZWxlbWVudC5lbC5jbG9zZXN0KFwiYXJjZ2lzLXNjZW5lXCIpO1xuICAgICAgICBpZiAodmlld1JlZj8udmlldykge1xuICAgICAgICAgICAgZWxlbWVudC52aWV3ID0gdmlld1JlZi52aWV3O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZpZXdSZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmlld1JlZi5yZW1vdmVFdmVudExpc3RlbmVyKFwiYXJjZ2lzVmlld1JlYWR5Q2hhbmdlXCIsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnZpZXcgPSB2aWV3UmVmLnZpZXc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmlld1JlZi5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzVmlld1JlYWR5Q2hhbmdlXCIsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTnVsbE9yRW1wdHlTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gXCJcIjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdmFsdWUgJSAxID09PSAwO1xufVxuZnVuY3Rpb24gaXNOb3RTYW1lQ2FtZXJhKGNhbWVyYSwgY2FtZXJhMikge1xuICAgIHJldHVybiAoY2FtZXJhMiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGNhbWVyYS5wb3NpdGlvbiAhPT0gY2FtZXJhMi5wb3NpdGlvbiB8fFxuICAgICAgICBjYW1lcmEuaGVhZGluZyAhPT0gY2FtZXJhMi5oZWFkaW5nIHx8XG4gICAgICAgIGNhbWVyYS50aWx0ICE9PSBjYW1lcmEyLnRpbHQpO1xufVxuZnVuY3Rpb24gaXNOb3RTYW1lRW52aXJvbm1lbnQoZW52aXJvbm1lbnQsIGVudmlyb25tZW50Mikge1xuICAgIHJldHVybiAoZW52aXJvbm1lbnQyID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgZW52aXJvbm1lbnQyLmF0bW9zcGhlcmVFbmFibGVkICE9PSBlbnZpcm9ubWVudC5hdG1vc3BoZXJlRW5hYmxlZCB8fFxuICAgICAgICBlbnZpcm9ubWVudDIubGlnaHRpbmcuZGF0ZSAhPT0gZW52aXJvbm1lbnQubGlnaHRpbmcuZGF0ZSB8fFxuICAgICAgICBlbnZpcm9ubWVudDIubGlnaHRpbmcuZGlyZWN0U2hhZG93c0VuYWJsZWQgIT09XG4gICAgICAgICAgICBlbnZpcm9ubWVudC5saWdodGluZy5kaXJlY3RTaGFkb3dzRW5hYmxlZCB8fFxuICAgICAgICBlbnZpcm9ubWVudDIubGlnaHRpbmcuY2FtZXJhVHJhY2tpbmdFbmFibGVkICE9PVxuICAgICAgICAgICAgZW52aXJvbm1lbnQubGlnaHRpbmcuY2FtZXJhVHJhY2tpbmdFbmFibGVkIHx8XG4gICAgICAgIGVudmlyb25tZW50Mi5saWdodGluZy5kYXRlICE9PSBlbnZpcm9ubWVudC5saWdodGluZy5kYXRlIHx8XG4gICAgICAgIGVudmlyb25tZW50Mi5saWdodGluZy5kaXNwbGF5VVRDT2Zmc2V0ICE9PVxuICAgICAgICAgICAgZW52aXJvbm1lbnQubGlnaHRpbmcuZGlzcGxheVVUQ09mZnNldCk7XG59XG5mdW5jdGlvbiBpc05vdFNhbWVWaWV3cG9pbnQodmlld3BvaW50LCB2aWV3cG9pbnQyKSB7XG4gICAgcmV0dXJuICh2aWV3cG9pbnQyID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgdmlld3BvaW50LnRhcmdldEdlb21ldHJ5ICE9PSB2aWV3cG9pbnQyLnRhcmdldEdlb21ldHJ5IHx8XG4gICAgICAgIHZpZXdwb2ludC5yb3RhdGlvbiAhPT0gdmlld3BvaW50Mi5yb3RhdGlvbiB8fFxuICAgICAgICB2aWV3cG9pbnQuc2NhbGUgIT09IHZpZXdwb2ludDIuc2NhbGUpO1xufVxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlRm9yVmlldyh2aWV3U3RyKSB7XG4gICAgY29uc3Qgdmlld1JlZiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iodmlld1N0cik7XG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGlmICh2aWV3UmVmPy52aWV3ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc29sdmUodmlld1JlZi52aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2aWV3UmVmKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZpZXdSZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFyY2dpc1ZpZXdSZWFkeUNoYW5nZVwiLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh2aWV3UmVmLnZpZXcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZpZXdSZWYuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc1ZpZXdSZWFkeUNoYW5nZVwiLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlZmVyZW5jZUVsZW1lbnRIZWxwZXIoZWxlbWVudCwgcmVmRWxlbWVudCkge1xuICAgIGlmIChyZWZFbGVtZW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBlbHNlIGlmICh0eXBlb2YgcmVmRWxlbWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBlbGVtZW50LnZpZXcgPSBhd2FpdCB1cGRhdGVGb3JWaWV3KHJlZkVsZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbGVtZW50LndpZGdldCkge1xuICAgICAgICBlbGVtZW50LnZpZXcgPSByZWZFbGVtZW50LnZpZXc7XG4gICAgfVxufVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy9cbi8vICBQcml2YXRlIE1ldGhvZHNcbi8vXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiB3YWl0Rm9yVmlld0hhbmRsZXIodmlld1JlZiwgZWxlbWVudCwgaXNVc2luZ1JlZmVybmNlRWxlbWVudCkge1xuICAgIGNvbnN0IGhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHZpZXdSZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFyY2dpc1ZpZXdSZWFkeUNoYW5nZVwiLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIGVsZW1lbnQudmlldyA9IHZpZXdSZWYudmlldztcbiAgICAgICAgaWYgKCFpc1VzaW5nUmVmZXJuY2VFbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LnZpZXcudWkuYWRkKGVsZW1lbnQuY2hpbGRFbGVtID8/IGVsZW1lbnQuZWwsIGVsZW1lbnQucG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2aWV3UmVmLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNWaWV3UmVhZHlDaGFuZ2VcIiwgaGFuZGxlciwgZmFsc2UpO1xufVxuXG5leHBvcnQgeyBhZGRIYW5kbGVzIGFzIGEsIGlzTm90U2FtZVZpZXdwb2ludCBhcyBiLCBjaGVja0ZvclZpZXcgYXMgYywgY2hlY2tGb3JFeHBhbmQgYXMgZCwgaXNOb3RTYW1lQ2FtZXJhIGFzIGUsIGlzTm90U2FtZUVudmlyb25tZW50IGFzIGYsIGlzVmFsaWRJbnRlZ2VyIGFzIGcsIGlzTnVsbE9yRW1wdHlTdHJpbmcgYXMgaSwgcmVmZXJlbmNlRWxlbWVudEhlbHBlciBhcyByIH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRXNyaSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9qcy5hcmNnaXMuY29tLzQuMzAvZXNyaS9jb3B5cmlnaHQudHh0IGZvciBkZXRhaWxzLlxuICogdjQuMzAuMC1uZXh0LjM3XG4gKi9cbi8vIHNyYy9hcnJheS11dGlscy50c1xuXG4vLyBzcmMvY3NzLXV0aWxzLnRzXG5mdW5jdGlvbiBjbGFzc2VzKC4uLmNsYXNzZXMyKSB7XG4gIGNvbnN0IGVmZmVjdGl2ZUNsYXNzZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc2VzMi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFyZyA9IGNsYXNzZXMyW2ldO1xuICAgIGlmICh0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBlZmZlY3RpdmVDbGFzc2VzLnB1c2goYXJnKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgZWZmZWN0aXZlQ2xhc3Nlcy5wdXNoLmFwcGx5KGVmZmVjdGl2ZUNsYXNzZXMsIGFyZyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gYXJnKSB7XG4gICAgICAgIGlmIChhcmdbcHJvcF0pIHtcbiAgICAgICAgICBlZmZlY3RpdmVDbGFzc2VzLnB1c2gocHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgY2xhc3NOYW1lID0gZWZmZWN0aXZlQ2xhc3Nlcy5qb2luKFwiIFwiKTtcbiAgZWZmZWN0aXZlQ2xhc3Nlcy5sZW5ndGggPSAwO1xuICByZXR1cm4gY2xhc3NOYW1lO1xufVxuXG4vLyBzcmMvdGV4dC50c1xudmFyIGtlYmFiVG9QYXNjYWwgPSAobmFtZSkgPT4gbmFtZS5zcGxpdChcIi1cIikubWFwKChwYXJ0KSA9PiAocGFydFswXT8udG9Mb2NhbGVVcHBlckNhc2UoKSA/PyBcIlwiKSArIHBhcnQuc2xpY2UoMSkpLmpvaW4oXCJcIik7XG52YXIgY2FwaXRhbGl6ZSA9IChzdHJpbmcpID0+IHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbnZhciBjYW1lbFRvSHVtYW4gPSAodmFsdWUpID0+IGNhcGl0YWxpemUodmFsdWUucmVwbGFjZUFsbCgvKFthLXpdKShbQS1aXSkvZ3UsIFwiJDEgJDJcIikpO1xubmV3IFByb3h5KFxuICB7fSxcbiAge1xuICAgIGdldDogKF90YXJnZXQsIHByb3BlcnR5KSA9PiBjYW1lbFRvSHVtYW4ocHJvcGVydHkudG9TdHJpbmcoKSlcbiAgfVxuKTtcblxuZXhwb3J0IHsgY2xhc3NlcyBhcyBjLCBrZWJhYlRvUGFzY2FsIGFzIGsgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==